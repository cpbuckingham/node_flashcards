/* ../../libs/bem-core/node_modules/ym/modules.js begin */
/**
 * Modules
 *
 * Copyright (c) 2013 Filatov Dmitry (dfilatov@yandex-team.ru)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * @version 0.0.15
 */

(function(global) {

var undef,
    DECL_STATES = {
        NOT_RESOLVED : 'NOT_RESOLVED',
        IN_RESOLVING : 'IN_RESOLVING',
        RESOLVED     : 'RESOLVED'
    },

    /**
     * Creates a new instance of modular system
     * @returns {Object}
     */
    create = function() {
        var curOptions = {
                trackCircularDependencies : true,
                allowMultipleDeclarations : true,
                onError                   : function(e) {
                    throw e;
                }
            },

            modulesStorage = {},
            declsToCalc = [],
            waitForNextTick = false,
            pendingRequires = [],

            /**
             * Defines module
             * @param {String} name
             * @param {String[]} [deps]
             * @param {Function} declFn
             */
            define = function(name, deps, declFn) {
                if(!declFn) {
                    declFn = deps;
                    deps = [];
                }

                var module = modulesStorage[name];
                if(module) {
                    if(!curOptions.allowMultipleDeclarations) {
                        onMultipleDeclarationDetected(name);
                        return;
                    }
                }
                else {
                    module = modulesStorage[name] = {
                        name : name,
                        decl : undef
                    };
                }

                declsToCalc.push(module.decl = {
                    name          : name,
                    fn            : declFn,
                    state         : DECL_STATES.NOT_RESOLVED,
                    deps          : deps,
                    prevDecl      : module.decl,
                    dependOnDecls : [],
                    dependents    : [],
                    exports       : undef
                });
            },

            /**
             * Requires modules
             * @param {String[]} modules
             * @param {Function} cb
             */
            require = function(modules, cb) {
                if(!waitForNextTick) {
                    waitForNextTick = true;
                    nextTick(onNextTick);
                }

                pendingRequires.push({
                    modules : modules,
                    cb      : cb
                });
            },

            /**
             * Returns state of module
             * @param {String} name
             * @returns {String} state, possible values are NOT_DEFINED, NOT_RESOLVED, IN_RESOLVING, RESOLVED
             */
            getState = function(name) {
                var module = modulesStorage[name];
                return module?
                    DECL_STATES[module.decl.state] :
                    'NOT_DEFINED';
            },

            /**
             * Returns whether the module is defined
             * @param {String} name
             * @returns {Boolean}
             */
            isDefined = function(name) {
                return !!modulesStorage[name];
            },

            /**
             * Sets options
             * @param {Object} options
             */
            setOptions = function(options) {
                for(var name in options) {
                    if(options.hasOwnProperty(name)) {
                        curOptions[name] = options[name];
                    }
                }
            },

            onNextTick = function() {
                waitForNextTick = false;
                if(calcDeclDeps()) {
                    applyRequires();
                }
            },

            calcDeclDeps = function() {
                var i = 0, decl, j, dep, dependOnDecls,
                    hasError = false;
                while(decl = declsToCalc[i++]) {
                    j = 0;
                    dependOnDecls = decl.dependOnDecls;
                    while(dep = decl.deps[j++]) {
                        if(!isDefined(dep)) {
                            onModuleNotFound(dep, decl);
                            hasError = true;
                            break;
                        }
                        dependOnDecls.push(modulesStorage[dep].decl);
                    }

                    if(hasError) {
                        break;
                    }

                    if(decl.prevDecl) {
                        dependOnDecls.push(decl.prevDecl);
                        decl.prevDecl = undef;
                    }
                }

                declsToCalc = [];
                return !hasError;
            },

            applyRequires = function() {
                var requiresToProcess = pendingRequires,
                    require, i = 0, j, dep, dependOnDecls, applyCb;

                pendingRequires = [];

                while(require = requiresToProcess[i++]) {
                    j = 0; dependOnDecls = []; applyCb = true;
                    while(dep = require.modules[j++]) {
                        if(!isDefined(dep)) {
                            onModuleNotFound(dep);
                            applyCb = false;
                            break;
                        }

                        dependOnDecls.push(modulesStorage[dep].decl);
                    }
                    applyCb && applyRequire(dependOnDecls, require.cb);
                }
            },

            applyRequire = function(dependOnDecls, cb) {
                requireDecls(
                    dependOnDecls,
                    function(exports) {
                        cb.apply(global, exports);
                    },
                    []);
            },

            requireDecls = function(decls, cb, path) {
                var unresolvedDeclCnt = decls.length;

                if(unresolvedDeclCnt) {
                    var onDeclResolved,
                        i = 0, decl;

                    while(decl = decls[i++]) {
                        if(decl.state === DECL_STATES.RESOLVED) {
                            --unresolvedDeclCnt;
                        }
                        else {
                            if(curOptions.trackCircularDependencies && isDependenceCircular(decl, path)) {
                                onCircularDependenceDetected(decl, path);
                            }

                            decl.state === DECL_STATES.NOT_RESOLVED && startDeclResolving(decl, path);

                            decl.state === DECL_STATES.RESOLVED? // decl resolved synchronously
                                --unresolvedDeclCnt :
                                decl.dependents.push(onDeclResolved || (onDeclResolved = function() {
                                    --unresolvedDeclCnt || onDeclsResolved(decls, cb);
                                }));
                        }
                    }
                }

                unresolvedDeclCnt || onDeclsResolved(decls, cb);
            },

            onDeclsResolved = function(decls, cb) {
                var exports = [],
                    i = 0, decl;
                while(decl = decls[i++]) {
                    exports.push(decl.exports);
                }
                cb(exports);
            },

            startDeclResolving = function(decl, path) {
                curOptions.trackCircularDependencies && (path = path.slice()).push(decl);
                decl.state = DECL_STATES.IN_RESOLVING;
                var isProvided = false;
                requireDecls(
                    decl.dependOnDecls,
                    function(depDeclsExports) {
                        decl.fn.apply(
                            {
                                name   : decl.name,
                                deps   : decl.deps,
                                global : global
                            },
                            [function(exports) {
                                isProvided?
                                    onDeclAlreadyProvided(decl) :
                                    isProvided = true;
                                provideDecl(decl, exports);
                                return exports;
                            }].concat(depDeclsExports));
                    },
                    path);
            },

            provideDecl = function(decl, exports) {
                decl.exports = exports;
                decl.state = DECL_STATES.RESOLVED;

                var i = 0, dependent;
                while(dependent = decl.dependents[i++]) {
                    dependent(decl.exports);
                }

                decl.dependents = undef;
            },

            onError = function(e) {
                nextTick(function() {
                    curOptions.onError(e);
                });
            },

            onModuleNotFound = function(name, decl) {
                onError(Error(
                    decl?
                        'Module "' + decl.name + '": can\'t resolve dependence "' + name + '"' :
                        'Required module "' + name + '" can\'t be resolved'));
            },

            onCircularDependenceDetected = function(decl, path) {
                var strPath = [],
                    i = 0, pathDecl;
                while(pathDecl = path[i++]) {
                    strPath.push(pathDecl.name);
                }
                strPath.push(decl.name);

                onError(Error('Circular dependence is detected: "' + strPath.join(' -> ') + '"'));
            },

            onDeclAlreadyProvided = function(decl) {
                onError(Error('Declaration of module "' + decl.name + '" is already provided'));
            },

            onMultipleDeclarationDetected = function(name) {
                onError(Error('Multiple declarations of module "' + name + '" are detected'));
            };

        return {
            create     : create,
            define     : define,
            require    : require,
            getState   : getState,
            isDefined  : isDefined,
            setOptions : setOptions
        };
    },

    isDependenceCircular = function(decl, path) {
        var i = 0, pathDecl;
        while(pathDecl = path[i++]) {
            if(decl === pathDecl) {
                return true;
            }
        }
        return false;
    },

    nextTick = (function() {
        var fns = [],
            enqueueFn = function(fn) {
                return fns.push(fn) === 1;
            },
            callFns = function() {
                var fnsToCall = fns, i = 0, len = fns.length;
                fns = [];
                while(i < len) {
                    fnsToCall[i++]();
                }
            };

        if(typeof process === 'object' && process.nextTick) { // nodejs
            return function(fn) {
                enqueueFn(fn) && process.nextTick(callFns);
            };
        }

        if(global.setImmediate) { // ie10
            return function(fn) {
                enqueueFn(fn) && global.setImmediate(callFns);
            };
        }

        if(global.postMessage && !global.opera) { // modern browsers
            var isPostMessageAsync = true;
            if(global.attachEvent) {
                var checkAsync = function() {
                        isPostMessageAsync = false;
                    };
                global.attachEvent('onmessage', checkAsync);
                global.postMessage('__checkAsync', '*');
                global.detachEvent('onmessage', checkAsync);
            }

            if(isPostMessageAsync) {
                var msg = '__modules' + (+new Date()),
                    onMessage = function(e) {
                        if(e.data === msg) {
                            e.stopPropagation && e.stopPropagation();
                            callFns();
                        }
                    };

                global.addEventListener?
                    global.addEventListener('message', onMessage, true) :
                    global.attachEvent('onmessage', onMessage);

                return function(fn) {
                    enqueueFn(fn) && global.postMessage(msg, '*');
                };
            }
        }

        var doc = global.document;
        if('onreadystatechange' in doc.createElement('script')) { // ie6-ie8
            var head = doc.getElementsByTagName('head')[0],
                createScript = function() {
                    var script = doc.createElement('script');
                    script.onreadystatechange = function() {
                        script.parentNode.removeChild(script);
                        script = script.onreadystatechange = null;
                        callFns();
                    };
                    head.appendChild(script);
                };

            return function(fn) {
                enqueueFn(fn) && createScript();
            };
        }

        return function(fn) { // old browsers
            enqueueFn(fn) && setTimeout(callFns, 0);
        };
    })();

if(typeof exports === 'object') {
    module.exports = create();
}
else {
    global.modules = create();
}

})(this);

/* ../../libs/bem-core/node_modules/ym/modules.js end */
;
/* ../../libs/bem-core/common.blocks/i-bem/i-bem.vanilla.js begin */
/**
 * @module i-bem
 */

modules.define(
    'i-bem',
    [
        'i-bem__internal',
        'inherit',
        'identify',
        'next-tick',
        'objects',
        'functions',
        'events'
    ],
    function(
        provide,
        INTERNAL,
        inherit,
        identify,
        nextTick,
        objects,
        functions,
        events) {

var undef,

    MOD_DELIM = INTERNAL.MOD_DELIM,
    ELEM_DELIM = INTERNAL.ELEM_DELIM,

    /**
     * Storage for block init functions
     * @private
     * @type Array
     */
    initFns = [],

    /**
     * Storage for block declarations (hash by block name)
     * @private
     * @type Object
     */
    blocks = {};

/**
 * Builds the name of the handler method for setting a modifier
 * @param {String} prefix
 * @param {String} modName Modifier name
 * @param {String} modVal Modifier value
 * @param {String} [elemName] Element name
 * @returns {String}
 */
function buildModFnName(prefix, modName, modVal, elemName) {
    return '__' + prefix +
        (elemName? '__elem_' + elemName : '') +
       '__mod' +
       (modName? '_' + modName : '') +
       (modVal? '_' + modVal : '');
}

/**
 * Transforms a hash of modifier handlers to methods
 * @param {String} prefix
 * @param {Object} modFns
 * @param {Object} props
 * @param {String} [elemName]
 */
function modFnsToProps(prefix, modFns, props, elemName) {
    if(functions.isFunction(modFns)) {
        props[buildModFnName(prefix, '*', '*', elemName)] = modFns;
    } else {
        var modName, modVal, modFn;
        for(modName in modFns) {
            if(modFns.hasOwnProperty(modName)) {
                modFn = modFns[modName];
                if(functions.isFunction(modFn)) {
                    props[buildModFnName(prefix, modName, '*', elemName)] = modFn;
                } else {
                    for(modVal in modFn) {
                        if(modFn.hasOwnProperty(modVal)) {
                            props[buildModFnName(prefix, modName, modVal, elemName)] = modFn[modVal];
                        }
                    }
                }
            }
        }
    }
}

function buildCheckMod(modName, modVal) {
    return modVal?
        Array.isArray(modVal)?
            function(block) {
                var i = 0, len = modVal.length;
                while(i < len)
                    if(block.hasMod(modName, modVal[i++]))
                        return true;
                return false;
            } :
            function(block) {
                return block.hasMod(modName, modVal);
            } :
        function(block) {
            return block.hasMod(modName);
        };
}

function convertModHandlersToMethods(props) {
    if(props.beforeSetMod) {
        modFnsToProps('before', props.beforeSetMod, props);
        delete props.beforeSetMod;
    }

    if(props.onSetMod) {
        modFnsToProps('after', props.onSetMod, props);
        delete props.onSetMod;
    }

    var elemName;
    if(props.beforeElemSetMod) {
        for(elemName in props.beforeElemSetMod) {
            if(props.beforeElemSetMod.hasOwnProperty(elemName)) {
                modFnsToProps('before', props.beforeElemSetMod[elemName], props, elemName);
            }
        }
        delete props.beforeElemSetMod;
    }

    if(props.onElemSetMod) {
        for(elemName in props.onElemSetMod) {
            if(props.onElemSetMod.hasOwnProperty(elemName)) {
                modFnsToProps('after', props.onElemSetMod[elemName], props, elemName);
            }
        }
        delete props.onElemSetMod;
    }
}

/**
 * @class BEM
 * @description Base block for creating BEM blocks
 * @augments events:Emitter
 * @exports
 */
var BEM = inherit(events.Emitter, /** @lends BEM.prototype */ {
    /**
     * @constructor
     * @private
     * @param {Object} mods Block modifiers
     * @param {Object} params Block parameters
     * @param {Boolean} [initImmediately=true]
     */
    __constructor : function(mods, params, initImmediately) {
        /**
         * Cache of block modifiers
         * @member {Object}
         * @private
         */
        this._modCache = mods || {};

        /**
         * Current modifiers in the stack
         * @member {Object}
         * @private
         */
        this._processingMods = {};

        /**
         * Block parameters, taking into account the defaults
         * @member {Object}
         * @readonly
         */
        this.params = objects.extend(this.getDefaultParams(), params);

        initImmediately !== false?
            this._init() :
            initFns.push(this._init, this);
    },

    /**
     * Initializes the block
     * @private
     */
    _init : function() {
        return this.setMod('js', 'inited');
    },

    /**
     * Adds an event handler
     * @param {String|Object} e Event type
     * @param {Object} [data] Additional data that the handler gets as e.data
     * @param {Function} fn Handler
     * @param {Object} [ctx] Handler context
     * @returns {this}
     */
    on : function(e, data, fn, ctx) {
        if(typeof e === 'object' && (functions.isFunction(data) || functions.isFunction(fn))) { // mod change event
            e = this.__self._buildModEventName(e);
        }

        return this.__base.apply(this, arguments);
    },

    /**
     * Removes event handler or handlers
     * @param {String|Object} [e] Event type
     * @param {Function} [fn] Handler
     * @param {Object} [ctx] Handler context
     * @returns {this}
     */
    un : function(e, fn, ctx) {
        if(typeof e === 'object' && functions.isFunction(fn)) { // mod change event
            e = this.__self._buildModEventName(e);
        }

        return this.__base.apply(this, arguments);
    },

    /**
     * Executes the block's event handlers and live event handlers
     * @protected
     * @param {String} e Event name
     * @param {Object} [data] Additional information
     * @returns {this}
     */
    emit : function(e, data) {
        var isModJsEvent = false;
        if(typeof e === 'object' && !(e instanceof events.Event)) {
            isModJsEvent = e.modName === 'js';
            e = this.__self._buildModEventName(e);
        }

        if(isModJsEvent || this.hasMod('js', 'inited')) {
            this.__base(e = this._buildEvent(e), data);
            this._ctxEmit(e, data);
        }

        return this;
    },

    _ctxEmit : function(e, data) {
        this.__self.emit(e, data);
    },

    /**
     * Builds event
     * @private
     * @param {String|events:Event} e
     * @returns {events:Event}
     */
    _buildEvent : function(e) {
        typeof e === 'string'?
            e = new events.Event(e, this) :
            e.target || (e.target = this);

        return e;
    },

    /**
     * Checks whether a block or nested element has a modifier
     * @param {Object} [elem] Nested element
     * @param {String} modName Modifier name
     * @param {String} [modVal] Modifier value
     * @returns {Boolean}
     */
    hasMod : function(elem, modName, modVal) {
        var len = arguments.length,
            invert = false;

        if(len === 1) {
            modVal = '';
            modName = elem;
            elem = undef;
            invert = true;
        } else if(len === 2) {
            if(typeof elem === 'string') {
                modVal = modName;
                modName = elem;
                elem = undef;
            } else {
                modVal = '';
                invert = true;
            }
        }

        var res = this.getMod(elem, modName) === modVal;
        return invert? !res : res;
    },

    /**
     * Returns the value of the modifier of the block/nested element
     * @param {Object} [elem] Nested element
     * @param {String} modName Modifier name
     * @returns {String} Modifier value
     */
    getMod : function(elem, modName) {
        var type = typeof elem;
        if(type === 'string' || type === 'undefined') { // elem either omitted or undefined
            modName = elem || modName;
            var modCache = this._modCache;
            return modName in modCache?
                modCache[modName] || '' :
                modCache[modName] = this._extractModVal(modName);
        }

        return this._getElemMod(modName, elem);
    },

    /**
     * Returns the value of the modifier of the nested element
     * @private
     * @param {String} modName Modifier name
     * @param {Object} elem Nested element
     * @param {Object} [elemName] Nested element name
     * @returns {String} Modifier value
     */
    _getElemMod : function(modName, elem, elemName) {
        return this._extractModVal(modName, elem, elemName);
    },

    /**
     * Returns values of modifiers of the block/nested element
     * @param {Object} [elem] Nested element
     * @param {String} [...modNames] Modifier names
     * @returns {Object} Hash of modifier values
     */
    getMods : function(elem) {
        var hasElem = elem && typeof elem !== 'string',
            modNames = [].slice.call(arguments, hasElem? 1 : 0),
            res = this._extractMods(modNames, hasElem? elem : undef);

        if(!hasElem) { // caching
            modNames.length?
                modNames.forEach(function(name) {
                    this._modCache[name] = res[name];
                }, this) :
                this._modCache = res;
        }

        return res;
    },

    /**
     * Sets the modifier for a block/nested element
     * @param {Object} [elem] Nested element
     * @param {String} modName Modifier name
     * @param {String} modVal Modifier value
     * @returns {this}
     */
    setMod : function(elem, modName, modVal) {
        if(typeof modVal === 'undefined') {
            if(typeof elem === 'string') { // if no elem
                modVal = typeof modName === 'undefined'?
                    true :  // e.g. setMod('focused')
                    modName; // e.g. setMod('js', 'inited')
                modName = elem;
                elem = undef;
            } else { // if elem
                modVal = true; // e.g. setMod(elem, 'focused')
            }
        }

        if(!elem || elem[0]) {
            modVal === false && (modVal = '');

            var modId = (elem && elem[0]? identify(elem[0]) : '') + '_' + modName;

            if(this._processingMods[modId])
                return this;

            var elemName,
                curModVal = elem?
                    this._getElemMod(modName, elem, elemName = this.__self._extractElemNameFrom(elem)) :
                    this.getMod(modName);

            if(curModVal === modVal)
                return this;

            this._processingMods[modId] = true;

            var needSetMod = true,
                modFnParams = [modName, modVal, curModVal];

            elem && modFnParams.unshift(elem);

            var modVars = [['*', '*'], [modName, '*'], [modName, modVal]],
                prefixes = ['before', 'after'],
                i = 0, prefix, j, modVar;

            while(prefix = prefixes[i++]) {
                j = 0;
                while(modVar = modVars[j++]) {
                    if(this._callModFn(prefix, elemName, modVar[0], modVar[1], modFnParams) === false) {
                        needSetMod = false;
                        break;
                    }
                }

                if(!needSetMod) break;

                if(prefix === 'before') {
                    elem || (this._modCache[modName] = modVal); // cache only block mods
                    this._onSetMod(modName, modVal, curModVal, elem, elemName);
                }
            }

            this._processingMods[modId] = null;
            needSetMod && this._emitModChangeEvents(modName, modVal, curModVal, elem, elemName);
        }

        return this;
    },

    /**
     * Function after successfully changing the modifier of the block/nested element
     * @protected
     * @param {String} modName Modifier name
     * @param {String} modVal Modifier value
     * @param {String} oldModVal Old modifier value
     * @param {Object} [elem] Nested element
     * @param {String} [elemName] Element name
     */
    _onSetMod : function(modName, modVal, oldModVal, elem, elemName) {},

    _emitModChangeEvents : function(modName, modVal, oldModVal, elem, elemName) {
        var eventData = { modName : modName, modVal : modVal, oldModVal : oldModVal };
        elem && (eventData.elem = elem);
        this
            .emit({ modName : modName, modVal : '*', elem : elemName }, eventData)
            .emit({ modName : modName, modVal : modVal, elem : elemName }, eventData);
    },

    /**
     * Sets a modifier for a block/nested element, depending on conditions.
     * If the condition parameter is passed: when true, modVal1 is set; when false, modVal2 is set.
     * If the condition parameter is not passed: modVal1 is set if modVal2 was set, or vice versa.
     * @param {Object} [elem] Nested element
     * @param {String} modName Modifier name
     * @param {String} modVal1 First modifier value
     * @param {String} [modVal2] Second modifier value
     * @param {Boolean} [condition] Condition
     * @returns {this}
     */
    toggleMod : function(elem, modName, modVal1, modVal2, condition) {
        if(typeof elem === 'string') { // if this is a block
            condition = modVal2;
            modVal2 = modVal1;
            modVal1 = modName;
            modName = elem;
            elem = undef;
        }

        if(typeof modVal1 === 'undefined') { // boolean mod
            modVal1 = true;
        }

        if(typeof modVal2 === 'undefined') {
            modVal2 = '';
        } else if(typeof modVal2 === 'boolean') {
            condition = modVal2;
            modVal2 = '';
        }

        var modVal = this.getMod(elem, modName);
        (modVal === modVal1 || modVal === modVal2) &&
            this.setMod(
                elem,
                modName,
                typeof condition === 'boolean'?
                    (condition? modVal1 : modVal2) :
                    this.hasMod(elem, modName, modVal1)? modVal2 : modVal1);

        return this;
    },

    /**
     * Removes a modifier from a block/nested element
     * @protected
     * @param {Object} [elem] Nested element
     * @param {String} modName Modifier name
     * @returns {this}
     */
    delMod : function(elem, modName) {
        if(!modName) {
            modName = elem;
            elem = undef;
        }

        return this.setMod(elem, modName, '');
    },

    /**
     * Executes handlers for setting modifiers
     * @private
     * @param {String} prefix
     * @param {String} elemName Element name
     * @param {String} modName Modifier name
     * @param {String} modVal Modifier value
     * @param {Array} modFnParams Handler parameters
     */
    _callModFn : function(prefix, elemName, modName, modVal, modFnParams) {
        var modFnName = buildModFnName(prefix, modName, modVal, elemName);
        return this[modFnName]?
           this[modFnName].apply(this, modFnParams) :
           undef;
    },

    /**
     * Retrieves the value of the modifier
     * @private
     * @param {String} modName Modifier name
     * @param {Object} [elem] Element
     * @returns {String} Modifier value
     */
    _extractModVal : function(modName, elem) {
        return '';
    },

    /**
     * Retrieves name/value for a list of modifiers
     * @private
     * @param {Array} modNames Names of modifiers
     * @param {Object} [elem] Element
     * @returns {Object} Hash of modifier values by name
     */
    _extractMods : function(modNames, elem) {
        return {};
    },

    /**
     * Returns a block's default parameters
     * @protected
     * @returns {Object}
     */
    getDefaultParams : function() {
        return {};
    },

    /**
     * Deletes a block
     * @private
     */
    _destruct : function() {
        this.delMod('js');
    },

    /**
     * Executes given callback on next turn eventloop in block's context
     * @protected
     * @param {Function} fn callback
     * @returns {this}
     */
    nextTick : function(fn) {
        var _this = this;
        nextTick(function() {
            _this.hasMod('js', 'inited') && fn.call(_this);
        });
        return this;
    }
}, /** @lends BEM */{

    _name : 'i-bem',

    /**
     * Storage for block declarations (hash by block name)
     * @type Object
     */
    blocks : blocks,

    /**
     * Declares blocks and creates a block class
     * @param {String|Object} decl Block name (simple syntax) or description
     * @param {String} decl.block|decl.name Block name
     * @param {String} [decl.baseBlock] Name of the parent block
     * @param {Array} [decl.baseMix] Mixed block names
     * @param {String} [decl.modName] Modifier name
     * @param {String|Array} [decl.modVal] Modifier value
     * @param {Object} [props] Methods
     * @param {Object} [staticProps] Static methods
     * @returns {Function}
     */
    decl : function(decl, props, staticProps) {
        // string as block
        typeof decl === 'string' && (decl = { block : decl });
        // inherit from itself
        if(arguments.length <= 2 &&
                typeof decl === 'object' &&
                (!decl || (typeof decl.block !== 'string' && typeof decl.modName !== 'string'))) {
            staticProps = props;
            props = decl;
            decl = {};
        }
        typeof decl.block === 'undefined' && (decl.block = this.getName());

        var baseBlock;
        if(typeof decl.baseBlock === 'undefined')
            baseBlock = blocks[decl.block] || this;
        else if(typeof decl.baseBlock === 'string') {
            baseBlock = blocks[decl.baseBlock];
            if(!baseBlock)
                throw('baseBlock "' + decl.baseBlock + '" for "' + decl.block + '" is undefined');
        } else {
            baseBlock = decl.baseBlock;
        }

        convertModHandlersToMethods(props || (props = {}));

        if(decl.modName) {
            var checkMod = buildCheckMod(decl.modName, decl.modVal);
            objects.each(props, function(prop, name) {
                functions.isFunction(prop) &&
                    (props[name] = function() {
                        var method;
                        if(checkMod(this)) {
                            method = prop;
                        } else {
                            var baseMethod = baseBlock.prototype[name];
                            baseMethod && baseMethod !== prop &&
                                (method = this.__base);
                        }
                        return method?
                            method.apply(this, arguments) :
                            undef;
                    });
            });
        }

        if(staticProps && typeof staticProps.live === 'boolean') {
            var live = staticProps.live;
            staticProps.live = function() {
                return live;
            };
        }

        var block, baseBlocks = baseBlock;
        if(decl.baseMix) {
            baseBlocks = [baseBlocks];
            decl.baseMix.forEach(function(mixedBlock) {
                if(!blocks[mixedBlock]) {
                    throw('mix block "' + mixedBlock + '" for "' + decl.block + '" is undefined');
                }
                baseBlocks.push(blocks[mixedBlock]);
            });
        }

        decl.block === baseBlock.getName()?
            // makes a new "live" if the old one was already executed
            (block = inherit.self(baseBlocks, props, staticProps))._processLive(true) :
            (block = blocks[decl.block] = inherit(baseBlocks, props, staticProps))._name = decl.block;

        return block;
    },

    declMix : function(block, props, staticProps) {
        convertModHandlersToMethods(props || (props = {}));
        return blocks[block] = inherit(props, staticProps);
    },

    /**
     * Processes a block's live properties
     * @private
     * @param {Boolean} [heedLive=false] Whether to take into account that the block already processed its live properties
     * @returns {Boolean} Whether the block is a live block
     */
    _processLive : function(heedLive) {
        return false;
    },

    /**
     * Factory method for creating an instance of the block named
     * @param {String|Object} block Block name or description
     * @param {Object} [params] Block parameters
     * @returns {BEM}
     */
    create : function(block, params) {
        typeof block === 'string' && (block = { block : block });

        return new blocks[block.block](block.mods, params);
    },

    /**
     * Returns the name of the current block
     * @returns {String}
     */
    getName : function() {
        return this._name;
    },

    /**
     * Adds an event handler
     * @param {String|Object} e Event type
     * @param {Object} [data] Additional data that the handler gets as e.data
     * @param {Function} fn Handler
     * @param {Object} [ctx] Handler context
     * @returns {this}
     */
    on : function(e, data, fn, ctx) {
        if(typeof e === 'object' && (functions.isFunction(data) || functions.isFunction(fn))) { // mod change event
            e = this._buildModEventName(e);
        }

        return this.__base.apply(this, arguments);
    },

    /**
     * Removes event handler or handlers
     * @param {String|Object} [e] Event type
     * @param {Function} [fn] Handler
     * @param {Object} [ctx] Handler context
     * @returns {this}
     */
    un : function(e, fn, ctx) {
        if(typeof e === 'object' && functions.isFunction(fn)) { // mod change event
            e = this._buildModEventName(e);
        }

        return this.__base.apply(this, arguments);
    },

    _buildModEventName : function(modEvent) {
        var res = MOD_DELIM + modEvent.modName + MOD_DELIM + (modEvent.modVal === false? '' : modEvent.modVal);
        modEvent.elem && (res = ELEM_DELIM + modEvent.elem + res);
        return res;
    },

    /**
     * Retrieves the name of an element nested in a block
     * @private
     * @param {Object} elem Nested element
     * @returns {String|undefined}
     */
    _extractElemNameFrom : function(elem) {},

    /**
     * Executes the block init functions
     * @private
     */
    _runInitFns : function() {
        if(initFns.length) {
            var fns = initFns,
                fn, i = 0;

            initFns = [];
            while(fn = fns[i]) {
                fn.call(fns[i + 1]);
                i += 2;
            }
        }
    }
});

provide(BEM);

});

/* ../../libs/bem-core/common.blocks/i-bem/i-bem.vanilla.js end */
;
/* ../../libs/bem-core/common.blocks/i-bem/__internal/i-bem__internal.vanilla.js begin */
/**
 * @module i-bem__internal
 */

modules.define('i-bem__internal', function(provide) {

var undef,
    /**
     * Separator for modifiers and their values
     * @const
     * @type String
     */
    MOD_DELIM = '_',

    /**
     * Separator between names of a block and a nested element
     * @const
     * @type String
     */
    ELEM_DELIM = '__',

    /**
     * Pattern for acceptable element and modifier names
     * @const
     * @type String
     */
    NAME_PATTERN = '[a-zA-Z0-9-]+';

function isSimple(obj) {
    var typeOf = typeof obj;
    return typeOf === 'string' || typeOf === 'number' || typeOf === 'boolean';
}

function buildModPostfix(modName, modVal) {
    var res = '';
    /* jshint eqnull: true */
    if(modVal != null && modVal !== false) {
        res += MOD_DELIM + modName;
        modVal !== true && (res += MOD_DELIM + modVal);
    }
    return res;
}

function buildBlockClass(name, modName, modVal) {
    return name + buildModPostfix(modName, modVal);
}

function buildElemClass(block, name, modName, modVal) {
    return buildBlockClass(block, undef, undef) +
        ELEM_DELIM + name +
        buildModPostfix(modName, modVal);
}

provide(/** @exports */{
    NAME_PATTERN : NAME_PATTERN,

    MOD_DELIM : MOD_DELIM,
    ELEM_DELIM : ELEM_DELIM,

    buildModPostfix : buildModPostfix,

    /**
     * Builds the class of a block or element with a modifier
     * @param {String} block Block name
     * @param {String} [elem] Element name
     * @param {String} [modName] Modifier name
     * @param {String|Number} [modVal] Modifier value
     * @returns {String} Class
     */
    buildClass : function(block, elem, modName, modVal) {
        if(isSimple(modName)) {
            if(!isSimple(modVal)) {
                modVal = modName;
                modName = elem;
                elem = undef;
            }
        } else if(typeof modName !== 'undefined') {
            modName = undef;
        } else if(elem && typeof elem !== 'string') {
            elem = undef;
        }

        if(!(elem || modName)) { // optimization for simple case
            return block;
        }

        return elem?
            buildElemClass(block, elem, modName, modVal) :
            buildBlockClass(block, modName, modVal);
    },

    /**
     * Builds full classes for a buffer or element with modifiers
     * @param {String} block Block name
     * @param {String} [elem] Element name
     * @param {Object} [mods] Modifiers
     * @returns {String} Class
     */
    buildClasses : function(block, elem, mods) {
        if(elem && typeof elem !== 'string') {
            mods = elem;
            elem = undef;
        }

        var res = elem?
            buildElemClass(block, elem, undef, undef) :
            buildBlockClass(block, undef, undef);

        if(mods) {
            for(var modName in mods) {
                if(mods.hasOwnProperty(modName) && mods[modName]) {
                    res += ' ' + (elem?
                        buildElemClass(block, elem, modName, mods[modName]) :
                        buildBlockClass(block, modName, mods[modName]));
                }
            }
        }

        return res;
    }
});

});
/* ../../libs/bem-core/common.blocks/i-bem/__internal/i-bem__internal.vanilla.js end */
;
/* ../../libs/bem-core/common.blocks/inherit/inherit.vanilla.js begin */
/**
 * @module inherit
 * @version 2.2.1
 * @author Filatov Dmitry <dfilatov@yandex-team.ru>
 * @description This module provides some syntax sugar for "class" declarations, constructors, mixins, "super" calls and static members.
 */

(function(global) {

var hasIntrospection = (function(){'_';}).toString().indexOf('_') > -1,
    emptyBase = function() {},
    hasOwnProperty = Object.prototype.hasOwnProperty,
    objCreate = Object.create || function(ptp) {
        var inheritance = function() {};
        inheritance.prototype = ptp;
        return new inheritance();
    },
    objKeys = Object.keys || function(obj) {
        var res = [];
        for(var i in obj) {
            hasOwnProperty.call(obj, i) && res.push(i);
        }
        return res;
    },
    extend = function(o1, o2) {
        for(var i in o2) {
            hasOwnProperty.call(o2, i) && (o1[i] = o2[i]);
        }

        return o1;
    },
    toStr = Object.prototype.toString,
    isArray = Array.isArray || function(obj) {
        return toStr.call(obj) === '[object Array]';
    },
    isFunction = function(obj) {
        return toStr.call(obj) === '[object Function]';
    },
    noOp = function() {},
    needCheckProps = true,
    testPropObj = { toString : '' };

for(var i in testPropObj) { // fucking ie hasn't toString, valueOf in for
    testPropObj.hasOwnProperty(i) && (needCheckProps = false);
}

var specProps = needCheckProps? ['toString', 'valueOf'] : null;

function getPropList(obj) {
    var res = objKeys(obj);
    if(needCheckProps) {
        var specProp, i = 0;
        while(specProp = specProps[i++]) {
            obj.hasOwnProperty(specProp) && res.push(specProp);
        }
    }

    return res;
}

function override(base, res, add) {
    var addList = getPropList(add),
        j = 0, len = addList.length,
        name, prop;
    while(j < len) {
        if((name = addList[j++]) === '__self') {
            continue;
        }
        prop = add[name];
        if(isFunction(prop) &&
                (!hasIntrospection || prop.toString().indexOf('.__base') > -1)) {
            res[name] = (function(name, prop) {
                var baseMethod = base[name]?
                        base[name] :
                        name === '__constructor'? // case of inheritance from plane function
                            res.__self.__parent :
                            noOp;
                return function() {
                    var baseSaved = this.__base;
                    this.__base = baseMethod;
                    var res = prop.apply(this, arguments);
                    this.__base = baseSaved;
                    return res;
                };
            })(name, prop);
        } else {
            res[name] = prop;
        }
    }
}

function applyMixins(mixins, res) {
    var i = 1, mixin;
    while(mixin = mixins[i++]) {
        res?
            isFunction(mixin)?
                inherit.self(res, mixin.prototype, mixin) :
                inherit.self(res, mixin) :
            res = isFunction(mixin)?
                inherit(mixins[0], mixin.prototype, mixin) :
                inherit(mixins[0], mixin);
    }
    return res || mixins[0];
}

/**
* Creates class
* @exports
* @param {Function|Array} [baseClass|baseClassAndMixins] class (or class and mixins) to inherit from
* @param {Object} prototypeFields
* @param {Object} [staticFields]
* @returns {Function} class
*/
function inherit() {
    var args = arguments,
        withMixins = isArray(args[0]),
        hasBase = withMixins || isFunction(args[0]),
        base = hasBase? withMixins? applyMixins(args[0]) : args[0] : emptyBase,
        props = args[hasBase? 1 : 0] || {},
        staticProps = args[hasBase? 2 : 1],
        res = props.__constructor || (hasBase && base.prototype.__constructor)?
            function() {
                return this.__constructor.apply(this, arguments);
            } :
            hasBase?
                function() {
                    return base.apply(this, arguments);
                } :
                function() {};

    if(!hasBase) {
        res.prototype = props;
        res.prototype.__self = res.prototype.constructor = res;
        return extend(res, staticProps);
    }

    extend(res, base);

    res.__parent = base;

    var basePtp = base.prototype,
        resPtp = res.prototype = objCreate(basePtp);

    resPtp.__self = resPtp.constructor = res;

    props && override(basePtp, resPtp, props);
    staticProps && override(base, res, staticProps);

    return res;
}

inherit.self = function() {
    var args = arguments,
        withMixins = isArray(args[0]),
        base = withMixins? applyMixins(args[0], args[0][0]) : args[0],
        props = args[1],
        staticProps = args[2],
        basePtp = base.prototype;

    props && override(basePtp, basePtp, props);
    staticProps && override(base, base, staticProps);

    return base;
};

var defineAsGlobal = true;
if(typeof exports === 'object') {
    module.exports = inherit;
    defineAsGlobal = false;
}

if(typeof modules === 'object') {
    modules.define('inherit', function(provide) {
        provide(inherit);
    });
    defineAsGlobal = false;
}

if(typeof define === 'function') {
    define(function(require, exports, module) {
        module.exports = inherit;
    });
    defineAsGlobal = false;
}

defineAsGlobal && (global.inherit = inherit);

})(this);

/* ../../libs/bem-core/common.blocks/inherit/inherit.vanilla.js end */
;
/* ../../libs/bem-core/common.blocks/identify/identify.vanilla.js begin */
/**
 * @module identify
 */

modules.define('identify', function(provide) {

var counter = 0,
    expando = '__' + (+new Date),
    get = function() {
        return 'uniq' + (++counter);
    };

provide(
    /**
     * Makes unique ID
     * @exports
     * @param {Object} obj Object that needs to be identified
     * @param {Boolean} [onlyGet=false] Return a unique value only if it had already been assigned before
     * @returns {String} ID
     */
    function(obj, onlyGet) {
        if(!obj) return get();

        var key = 'uniqueID' in obj? 'uniqueID' : expando; // Use when possible native uniqueID for elements in IE

        return onlyGet || key in obj?
            obj[key] :
            obj[key] = get();
    }
);

});

/* ../../libs/bem-core/common.blocks/identify/identify.vanilla.js end */
;
/* ../../libs/bem-core/common.blocks/next-tick/next-tick.vanilla.js begin */
/**
 * @module next-tick
 */

modules.define('next-tick', function(provide) {

/**
 * Executes given function on next tick.
 * @exports
 * @type Function
 * @param {Function} fn
 */

var global = this.global,
    fns = [],
    enqueueFn = function(fn) {
        return fns.push(fn) === 1;
    },
    callFns = function() {
        var fnsToCall = fns, i = 0, len = fns.length;
        fns = [];
        while(i < len) {
            fnsToCall[i++]();
        }
    };

    /* global process */
    if(typeof process === 'object' && process.nextTick) { // nodejs
        return provide(function(fn) {
            enqueueFn(fn) && process.nextTick(callFns);
        });
    }

    if(global.setImmediate) { // ie10
        return provide(function(fn) {
            enqueueFn(fn) && global.setImmediate(callFns);
        });
    }

    if(global.postMessage) { // modern browsers
        var isPostMessageAsync = true;
        if(global.attachEvent) {
            var checkAsync = function() {
                    isPostMessageAsync = false;
                };
            global.attachEvent('onmessage', checkAsync);
            global.postMessage('__checkAsync', '*');
            global.detachEvent('onmessage', checkAsync);
        }

        if(isPostMessageAsync) {
            var msg = '__nextTick' + (+new Date),
                onMessage = function(e) {
                    if(e.data === msg) {
                        e.stopPropagation && e.stopPropagation();
                        callFns();
                    }
                };

            global.addEventListener?
                global.addEventListener('message', onMessage, true) :
                global.attachEvent('onmessage', onMessage);

            return provide(function(fn) {
                enqueueFn(fn) && global.postMessage(msg, '*');
            });
        }
    }

    var doc = global.document;
    if('onreadystatechange' in doc.createElement('script')) { // ie6-ie8
        var head = doc.getElementsByTagName('head')[0],
            createScript = function() {
                var script = doc.createElement('script');
                script.onreadystatechange = function() {
                    script.parentNode.removeChild(script);
                    script = script.onreadystatechange = null;
                    callFns();
                };
                head.appendChild(script);
            };

        return provide(function(fn) {
            enqueueFn(fn) && createScript();
        });
    }

    provide(function(fn) { // old browsers
        enqueueFn(fn) && global.setTimeout(callFns, 0);
    });
});

/* ../../libs/bem-core/common.blocks/next-tick/next-tick.vanilla.js end */
;
/* ../../libs/bem-core/common.blocks/objects/objects.vanilla.js begin */
/**
 * @module objects
 * @description A set of helpers to work with JavaScript objects
 */

modules.define('objects', function(provide) {

var hasOwnProp = Object.prototype.hasOwnProperty;

provide(/** @exports */{
    /**
     * Extends a given target by
     * @param {Object} target object to extend
     * @param {...Object} source
     * @returns {Object}
     */
    extend : function(target, source) {
        typeof target !== 'object' && (target = {});

        for(var i = 1, len = arguments.length; i < len; i++) {
            var obj = arguments[i];
            if(obj) {
                for(var key in obj) {
                    hasOwnProp.call(obj, key) && (target[key] = obj[key]);
                }
            }
        }

        return target;
    },

    /**
     * Check whether a given object is empty (contains no enumerable properties)
     * @param {Object} obj
     * @returns {Boolean}
     */
    isEmpty : function(obj) {
        for(var key in obj) {
            if(hasOwnProp.call(obj, key)) {
                return false;
            }
        }

        return true;
    },

    /**
     * Generic iterator function over object
     * @param {Object} obj object to iterate
     * @param {Function} fn callback
     * @param {Object} [ctx] callbacks's context
     */
    each : function(obj, fn, ctx) {
        for(var key in obj) {
            if(hasOwnProp.call(obj, key)) {
                ctx? fn.call(ctx, obj[key], key) : fn(obj[key], key);
            }
        }
    }
});

});

/* ../../libs/bem-core/common.blocks/objects/objects.vanilla.js end */
;
/* ../../libs/bem-core/common.blocks/functions/functions.vanilla.js begin */
/**
 * @module functions
 * @description A set of helpers to work with JavaScript functions
 */

modules.define('functions', function(provide) {

var toStr = Object.prototype.toString;

provide(/** @exports */{
    /**
     * Checks whether a given object is function
     * @param {*} obj
     * @returns {Boolean}
     */
    isFunction : function(obj) {
        return toStr.call(obj) === '[object Function]';
    },

    /**
     * Empty function
     */
    noop : function() {}
});

});

/* ../../libs/bem-core/common.blocks/functions/functions.vanilla.js end */
;
/* ../../libs/bem-core/common.blocks/events/events.vanilla.js begin */
/**
 * @module events
 */

modules.define(
    'events',
    ['identify', 'inherit', 'functions'],
    function(provide, identify, inherit, functions) {

var undef,
    storageExpando = '__' + (+new Date) + 'storage',
    getFnId = function(fn, ctx) {
        return identify(fn) + (ctx? identify(ctx) : '');
    },

    /**
     * @class Event
     * @exports events:Event
     */
    Event = inherit(/** @lends Event.prototype */{
        /**
         * @constructor
         * @param {String} type
         * @param {Object} target
         */
        __constructor : function(type, target) {
            /**
             * Type
             * @member {String} Event
             */
            this.type = type;

            /**
             * Target
             * @member {String} Event
             */
            this.target = target;

            /**
             * Result
             * @member {*}
             */
            this.result = undef;

            /**
             * Data
             * @member {*}
             */
            this.data = undef;

            this._isDefaultPrevented = false;
            this._isPropagationStopped = false;
        },

        /**
         * Prevents default action
         */
        preventDefault : function() {
            this._isDefaultPrevented = true;
        },

        /**
         * Returns whether is default action prevented
         * @returns {Boolean}
         */
        isDefaultPrevented : function() {
            return this._isDefaultPrevented;
        },

        /**
         * Stops propagation
         */
        stopPropagation : function() {
            this._isPropagationStopped = true;
        },

        /**
         * Returns whether is propagation stopped
         * @returns {Boolean}
         */
        isPropagationStopped : function() {
            return this._isPropagationStopped;
        }
    }),

    /**
     * @lends Emitter
     * @lends Emitter.prototype
     */
    EmitterProps = {
        /**
         * Adds an event handler
         * @param {String} e Event type
         * @param {Object} [data] Additional data that the handler gets as e.data
         * @param {Function} fn Handler
         * @param {Object} [ctx] Handler context
         * @returns {this}
         */
        on : function(e, data, fn, ctx, _special) {
            if(typeof e === 'string') {
                if(functions.isFunction(data)) {
                    ctx = fn;
                    fn = data;
                    data = undef;
                }

                var id = getFnId(fn, ctx),
                    storage = this[storageExpando] || (this[storageExpando] = {}),
                    eventTypes = e.split(' '), eventType,
                    i = 0, list, item,
                    eventStorage;

                while(eventType = eventTypes[i++]) {
                    eventStorage = storage[eventType] || (storage[eventType] = { ids : {}, list : {} });
                    if(!(id in eventStorage.ids)) {
                        list = eventStorage.list;
                        item = { fn : fn, data : data, ctx : ctx, special : _special };
                        if(list.last) {
                            list.last.next = item;
                            item.prev = list.last;
                        } else {
                            list.first = item;
                        }
                        eventStorage.ids[id] = list.last = item;
                    }
                }
            } else {
                for(var key in e) {
                    e.hasOwnProperty(key) && this.on(key, e[key], data, _special);
                }
            }

            return this;
        },

        /**
         * Adds a one time handler for the event.
         * Handler is executed only the next time the event is fired, after which it is removed.
         * @param {String} e Event type
         * @param {Object} [data] Additional data that the handler gets as e.data
         * @param {Function} fn Handler
         * @param {Object} [ctx] Handler context
         * @returns {this}
         */
        once : function(e, data, fn, ctx) {
            return this.on(e, data, fn, ctx, { once : true });
        },

        /**
         * Removes event handler or handlers
         * @param {String} [e] Event type
         * @param {Function} [fn] Handler
         * @param {Object} [ctx] Handler context
         * @returns {this}
         */
        un : function(e, fn, ctx) {
            if(typeof e === 'string' || typeof e === 'undefined') {
                var storage = this[storageExpando];
                if(storage) {
                    if(e) { // if event type was passed
                        var eventTypes = e.split(' '),
                            i = 0, eventStorage;
                        while(e = eventTypes[i++]) {
                            if(eventStorage = storage[e]) {
                                if(fn) {  // if specific handler was passed
                                    var id = getFnId(fn, ctx),
                                        ids = eventStorage.ids;
                                    if(id in ids) {
                                        var list = eventStorage.list,
                                            item = ids[id],
                                            prev = item.prev,
                                            next = item.next;

                                        if(prev) {
                                            prev.next = next;
                                        } else if(item === list.first) {
                                            list.first = next;
                                        }

                                        if(next) {
                                            next.prev = prev;
                                        } else if(item === list.last) {
                                            list.last = prev;
                                        }

                                        delete ids[id];
                                    }
                                } else {
                                    delete this[storageExpando][e];
                                }
                            }
                        }
                    } else {
                        delete this[storageExpando];
                    }
                }
            } else {
                for(var key in e) {
                    e.hasOwnProperty(key) && this.un(key, e[key], fn);
                }
            }

            return this;
        },

        /**
         * Fires event handlers
         * @param {String|events:Event} e Event
         * @param {Object} [data] Additional data
         * @returns {this}
         */
        emit : function(e, data) {
            var storage = this[storageExpando],
                eventInstantiated = false;

            if(storage) {
                var eventTypes = [typeof e === 'string'? e : e.type, '*'],
                    i = 0, eventType, eventStorage;
                while(eventType = eventTypes[i++]) {
                    if(eventStorage = storage[eventType]) {
                        var item = eventStorage.list.first,
                            lastItem = eventStorage.list.last,
                            res;
                        while(item) {
                            if(!eventInstantiated) { // instantiate Event only on demand
                                eventInstantiated = true;
                                typeof e === 'string' && (e = new Event(e));
                                e.target || (e.target = this);
                            }

                            e.data = item.data;
                            res = item.fn.apply(item.ctx || this, arguments);
                            if(typeof res !== 'undefined') {
                                e.result = res;
                                if(res === false) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                            }

                            item.special && item.special.once &&
                                this.un(e.type, item.fn, item.ctx);

                            if(item === lastItem) {
                                break;
                            }

                            item = item.next;
                        }
                    }
                }
            }

            return this;
        }
    },
    /**
     * @class Emitter
     * @exports events:Emitter
     */
    Emitter = inherit(
        EmitterProps,
        EmitterProps);

provide({
    Emitter : Emitter,
    Event : Event
});

});

/* ../../libs/bem-core/common.blocks/events/events.vanilla.js end */
;
/* ../../libs/bem-core/common.blocks/i-bem/__dom/i-bem__dom.js begin */
/**
 * @module i-bem__dom
 */

modules.define(
    'i-bem__dom',
    ['i-bem', 'i-bem__internal', 'identify', 'objects', 'functions', 'jquery', 'dom'],
    function(provide, BEM, INTERNAL, identify, objects, functions, $, dom) {

var undef,
    win = $(window),
    doc = $(document),

    /**
     * Storage for DOM elements by unique key
     * @type Object
     */
    uniqIdToDomElems = {},

    /**
     * Storage for blocks by unique key
     * @type Object
     */
    uniqIdToBlock = {},

    /**
     * Storage for DOM element's parent nodes
     * @type Object
     */
    domNodesToParents = {},

    /**
     * Storage for block parameters
     * @type Object
     */
    domElemToParams = {},

    /**
     * Storage for liveCtx event handlers
     * @type Object
     */
    liveEventCtxStorage = {},

    /**
     * Storage for liveClass event handlers
     * @type Object
     */
    liveClassEventStorage = {},

    blocks = BEM.blocks,

    BEM_CLASS = 'i-bem',
    BEM_SELECTOR = '.' + BEM_CLASS,
    BEM_PARAMS_ATTR = 'data-bem',

    NAME_PATTERN = INTERNAL.NAME_PATTERN,

    MOD_DELIM = INTERNAL.MOD_DELIM,
    ELEM_DELIM = INTERNAL.ELEM_DELIM,

    EXTRACT_MODS_RE = RegExp(
        '[^' + MOD_DELIM + ']' + MOD_DELIM + '(' + NAME_PATTERN + ')' +
        '(?:' + MOD_DELIM + '(' + NAME_PATTERN + '))?$'),

    buildModPostfix = INTERNAL.buildModPostfix,
    buildClass = INTERNAL.buildClass,

    reverse = Array.prototype.reverse;

/**
 * Initializes blocks on a DOM element
 * @param {jQuery} domElem DOM element
 * @param {String} uniqInitId ID of the "initialization wave"
 */
function initBlocks(domElem, uniqInitId) {
    var domNode = domElem[0],
        params = getParams(domNode),
        blockName;

    for(blockName in params)
        initBlock(
            blockName,
            domElem,
            processParams(params[blockName], blockName, uniqInitId));
}

/**
 * Initializes a specific block on a DOM element, or returns the existing block if it was already created
 * @param {String} blockName Block name
 * @param {jQuery} domElem DOM element
 * @param {Object} [params] Initialization parameters
 * @param {Boolean} [forceLive=false] Force live initialization
 * @param {Function} [callback] Handler to call after complete initialization
 */
function initBlock(blockName, domElem, params, forceLive, callback) {
    var domNode = domElem[0];

    params || (params = processParams(getBlockParams(domNode, blockName), blockName));

    var uniqId = params.uniqId,
        block = uniqIdToBlock[uniqId];

    if(block) {
        if(block.domElem.index(domNode) < 0) {
            block.domElem = block.domElem.add(domElem);
            objects.extend(block.params, params);
        }

        return block;
    }

    uniqIdToDomElems[uniqId] = uniqIdToDomElems[uniqId]?
        uniqIdToDomElems[uniqId].add(domElem) :
        domElem;

    var parentDomNode = domNode.parentNode;
    if(!parentDomNode || parentDomNode.nodeType === 11) { // jquery doesn't unique disconnected node
        $.unique(uniqIdToDomElems[uniqId]);
    }

    var blockClass = blocks[blockName] || DOM.decl(blockName, {}, { live : true }, true);
    if(!(blockClass._liveInitable = !!blockClass._processLive()) || forceLive || params.live === false) {
        forceLive && domElem.addClass(BEM_CLASS); // add css class for preventing memory leaks in further destructing

        block = new blockClass(uniqIdToDomElems[uniqId], params, !!forceLive);

        delete uniqIdToDomElems[uniqId];
        callback && callback.apply(block, Array.prototype.slice.call(arguments, 4));
        return block;
    }
}

/**
 * Processes and adds necessary block parameters
 * @param {Object} params Initialization parameters
 * @param {String} blockName Block name
 * @param {String} [uniqInitId] ID of the "initialization wave"
 */
function processParams(params, blockName, uniqInitId) {
    params.uniqId ||
        (params.uniqId = (params.id?
            blockName + '-id-' + params.id :
            identify()) + (uniqInitId || identify()));

    return params;
}

/**
 * Helper for searching for a DOM element using a selector inside the context, including the context itself
 * @param {jQuery} ctx Context
 * @param {String} selector CSS selector
 * @param {Boolean} [excludeSelf=false] Exclude context from search
 * @returns {jQuery}
 */
function findDomElem(ctx, selector, excludeSelf) {
    var res = ctx.find(selector);
    return excludeSelf?
       res :
       res.add(ctx.filter(selector));
}

/**
 * Returns parameters of a block's DOM element
 * @param {HTMLElement} domNode DOM node
 * @returns {Object}
 */
function getParams(domNode, blockName) {
    var uniqId = identify(domNode);
    return domElemToParams[uniqId] ||
        (domElemToParams[uniqId] = extractParams(domNode));
}

/**
 * Returns parameters of a block extracted from DOM node
 * @param {HTMLElement} domNode DOM node
 * @param {String} blockName
 * @returns {Object}
 */

function getBlockParams(domNode, blockName) {
    var params = getParams(domNode);
    return params[blockName] || (params[blockName] = {});
}

/**
 * Retrieves block parameters from a DOM element
 * @param {HTMLElement} domNode DOM node
 * @returns {Object}
 */
function extractParams(domNode) {
    var attrVal = domNode.getAttribute(BEM_PARAMS_ATTR);
    return attrVal? JSON.parse(attrVal) : {};
}

/**
 * Uncouple DOM node from the block. If this is the last node, then destroys the block.
 * @param {BEMDOM} block block
 * @param {HTMLElement} domNode DOM node
 */
function removeDomNodeFromBlock(block, domNode) {
    block.domElem.length === 1?
        block._destruct() :
        block.domElem = block.domElem.not(domNode);
}

/**
 * Fills DOM node's parent nodes to the storage
 * @param {jQuery} domElem
 */
function storeDomNodeParents(domElem) {
    domElem.each(function() {
        domNodesToParents[identify(this)] = this.parentNode;
    });
}

/**
 * @class BEMDOM
 * @description Base block for creating BEM blocks that have DOM representation
 * @exports
 */

var DOM = BEM.decl('i-bem__dom',/** @lends BEMDOM.prototype */{
    /**
     * @constructor
     * @private
     * @param {jQuery} domElem DOM element that the block is created on
     * @param {Object} params Block parameters
     * @param {Boolean} [initImmediately=true]
     */
    __constructor : function(domElem, params, initImmediately) {
        /**
         * DOM elements of block
         * @member {jQuery}
         * @readonly
         */
        this.domElem = domElem;

        /**
         * Cache for names of events on DOM elements
         * @member {Object}
         * @private
         */
        this._eventNameCache = {};

        /**
         * Cache for elements
         * @member {Object}
         * @private
         */
        this._elemCache = {};

        /**
         * @member {String} Unique block ID
         * @private
         */
        this._uniqId = params.uniqId;

        uniqIdToBlock[this._uniqId] = this;

        /**
         * @member {Boolean} Flag for whether it's necessary to unbind from the document and window when destroying the block
         * @private
         */
        this._needSpecialUnbind = false;

        this.__base(null, params, initImmediately);
    },

    /**
     * Finds blocks inside the current block or its elements (including context)
     * @param {String|jQuery} [elem] Block element
     * @param {String|Object} block Name or description (block,modName,modVal) of the block to find
     * @returns {BEMDOM[]}
     */
    findBlocksInside : function(elem, block) {
        return this._findBlocks('find', elem, block);
    },

    /**
     * Finds the first block inside the current block or its elements (including context)
     * @param {String|jQuery} [elem] Block element
     * @param {String|Object} block Name or description (block,modName,modVal) of the block to find
     * @returns {BEMDOM}
     */
    findBlockInside : function(elem, block) {
        return this._findBlocks('find', elem, block, true);
    },

    /**
     * Finds blocks outside the current block or its elements (including context)
     * @param {String|jQuery} [elem] Block element
     * @param {String|Object} block Name or description (block,modName,modVal) of the block to find
     * @returns {BEMDOM[]}
     */
    findBlocksOutside : function(elem, block) {
        return this._findBlocks('parents', elem, block);
    },

    /**
     * Finds the first block outside the current block or its elements (including context)
     * @param {String|jQuery} [elem] Block element
     * @param {String|Object} block Name or description (block,modName,modVal) of the block to find
     * @returns {BEMDOM}
     */
    findBlockOutside : function(elem, block) {
        return this._findBlocks('closest', elem, block)[0] || null;
    },

    /**
     * Finds blocks on DOM elements of the current block or its elements
     * @param {String|jQuery} [elem] Block element
     * @param {String|Object} block Name or description (block,modName,modVal) of the block to find
     * @returns {BEMDOM[]}
     */
    findBlocksOn : function(elem, block) {
        return this._findBlocks('', elem, block);
    },

    /**
     * Finds the first block on DOM elements of the current block or its elements
     * @param {String|jQuery} [elem] Block element
     * @param {String|Object} block Name or description (block,modName,modVal) of the block to find
     * @returns {BEMDOM}
     */
    findBlockOn : function(elem, block) {
        return this._findBlocks('', elem, block, true);
    },

    _findBlocks : function(select, elem, block, onlyFirst) {
        if(!block) {
            block = elem;
            elem = undef;
        }

        var ctxElem = elem?
                (typeof elem === 'string'? this.findElem(elem) : elem) :
                this.domElem,
            isSimpleBlock = typeof block === 'string',
            blockName = isSimpleBlock? block : (block.block || block.blockName),
            selector = '.' +
                (isSimpleBlock?
                    buildClass(blockName) :
                    buildClass(blockName, block.modName, block.modVal)) +
                (onlyFirst? ':first' : ''),
            domElems = ctxElem.filter(selector);

        select && (domElems = domElems.add(ctxElem[select](selector)));

        if(onlyFirst) {
            return domElems[0]? initBlock(blockName, domElems.eq(0), undef, true) : null;
        }

        var res = [],
            uniqIds = {};

        domElems.each(function(i, domElem) {
            var block = initBlock(blockName, $(domElem), undef, true);
            if(!uniqIds[block._uniqId]) {
                uniqIds[block._uniqId] = true;
                res.push(block);
            }
        });

        return res;
    },

    /**
     * Adds an event handler for any DOM element
     * @protected
     * @param {jQuery} domElem DOM element where the event will be listened for
     * @param {String|Object} event Event name or event object
     * @param {Function} fn Handler function, which will be executed in the block's context
     * @returns {this}
     */
    bindToDomElem : function(domElem, event, fn) {
        fn?
            domElem.bind(
                this._buildEventName(event),
                $.proxy(fn, this)) :
            objects.each(event, function(fn, event) {
                this.bindToDomElem(domElem, event, fn);
            }, this);

        return this;
    },

    /**
     * Adds an event handler to the document
     * @protected
     * @param {String} event Event name
     * @param {Function} fn Handler function, which will be executed in the block's context
     * @returns {this}
     */
    bindToDoc : function(event, fn) {
        this._needSpecialUnbind = true;
        return this.bindToDomElem(doc, event, fn);
    },

    /**
     * Adds an event handler to the window
     * @protected
     * @param {String} event Event name
     * @param {Function} fn Handler function, which will be executed in the block's context
     * @returns {this}
     */
    bindToWin : function(event, fn) {
        this._needSpecialUnbind = true;
        return this.bindToDomElem(win, event, fn);
    },

    /**
     * Adds an event handler to the block's main DOM elements or its nested elements
     * @protected
     * @param {jQuery|String} [elem] Element
     * @param {String} event Event name
     * @param {Function} fn Handler function, which will be executed in the block's context
     * @returns {this}
     */
    bindTo : function(elem, event, fn) {
        if(!event || functions.isFunction(event)) { // if there is no element
            fn = event;
            event = elem;
            elem = this.domElem;
        } else if(typeof elem === 'string') {
            elem = this.elem(elem);
        }

        return this.bindToDomElem(elem, event, fn);
    },

    /**
     * Removes event handlers from any DOM element
     * @protected
     * @param {jQuery} domElem DOM element where the event was being listened for
     * @param {String|Object} event Event name or event object
     * @param {Function} [fn] Handler function
     * @returns {this}
     */
    unbindFromDomElem : function(domElem, event, fn) {
        if(typeof event === 'string') {
            event = this._buildEventName(event);
            fn?
                domElem.unbind(event, fn) :
                domElem.unbind(event);
        } else {
            objects.each(event, function(fn, event) {
                this.unbindFromDomElem(domElem, event, fn);
            }, this);
        }

        return this;
    },

    /**
     * Removes event handler from document
     * @protected
     * @param {String|Object} event Event name or event object
     * @param {Function} [fn] Handler function
     * @returns {this}
     */
    unbindFromDoc : function(event, fn) {
        return this.unbindFromDomElem(doc, event, fn);
    },

    /**
     * Removes event handler from window
     * @protected
     * @param {String|Object} event Event name or event object
     * @param {Function} [fn] Handler function
     * @returns {this}
     */
    unbindFromWin : function(event, fn) {
        return this.unbindFromDomElem(win, event, fn);
    },

    /**
     * Removes event handlers from the block's main DOM elements or its nested elements
     * @protected
     * @param {jQuery|String} [elem] Nested element
     * @param {String|Object} event Event name or event object
     * @param {Function} [fn] Handler function
     * @returns {this}
     */
    unbindFrom : function(elem, event, fn) {
        var argLen = arguments.length;
        if(argLen === 1) {
            event = elem;
            elem = this.domElem;
        } else if(argLen === 2 && functions.isFunction(event)) {
            fn = event;
            event = elem;
            elem = this.domElem;
        } else if(typeof elem === 'string') {
            elem = this.elem(elem);
        }

        return this.unbindFromDomElem(elem, event, fn);
    },

    /**
     * Builds a full name for an event
     * @private
     * @param {String} event Event name
     * @returns {String}
     */
    _buildEventName : function(event) {
        return event.indexOf(' ') > 1?
            event.split(' ').map(function(e) {
                return this._buildOneEventName(e);
            }, this).join(' ') :
            this._buildOneEventName(event);
    },

    /**
     * Builds a full name for a single event
     * @private
     * @param {String} event Event name
     * @returns {String}
     */
    _buildOneEventName : function(event) {
        var eventNameCache = this._eventNameCache;

        if(event in eventNameCache) return eventNameCache[event];

        var uniq = '.' + this._uniqId;

        if(event.indexOf('.') < 0) return eventNameCache[event] = event + uniq;

        var lego = '.bem_' + this.__self._name;

        return eventNameCache[event] = event.split('.').map(function(e, i) {
            return i === 0? e + lego : lego + '_' + e;
        }).join('') + uniq;
    },

    _ctxEmit : function(e, data) {
        this.__base.apply(this, arguments);

        var _this = this,
            storage = liveEventCtxStorage[_this.__self._buildCtxEventName(e.type)],
            ctxIds = {};

        storage && _this.domElem.each(function(_, ctx) {
            var counter = storage.counter;
            while(ctx && counter) {
                var ctxId = identify(ctx, true);
                if(ctxId) {
                    if(ctxIds[ctxId]) break;
                    var storageCtx = storage.ctxs[ctxId];
                    if(storageCtx) {
                        objects.each(storageCtx, function(handler) {
                            handler.fn.call(
                                handler.ctx || _this,
                                e,
                                data);
                        });
                        counter--;
                    }
                    ctxIds[ctxId] = true;
                }
                ctx = ctx.parentNode || domNodesToParents[ctxId];
            }
        });
    },

    /**
     * Sets a modifier for a block/nested element
     * @param {jQuery} [elem] Nested element
     * @param {String} modName Modifier name
     * @param {String} modVal Modifier value
     * @returns {this}
     */
    setMod : function(elem, modName, modVal) {
        if(elem && typeof modVal !== 'undefined' && elem.length > 1) {
            var _this = this;
            elem.each(function() {
                var item = $(this);
                item.__bemElemName = elem.__bemElemName;
                _this.setMod(item, modName, modVal);
            });
            return _this;
        }
        return this.__base(elem, modName, modVal);
    },

    /**
     * Retrieves modifier value from the DOM node's CSS class
     * @private
     * @param {String} modName Modifier name
     * @param {jQuery} [elem] Nested element
     * @param {String} [elemName] Name of the nested element
     * @returns {String} Modifier value
     */
    _extractModVal : function(modName, elem, elemName) {
        var domNode = (elem || this.domElem)[0],
            matches;

        domNode &&
            (matches = domNode.className
                .match(this.__self._buildModValRE(modName, elemName || elem)));

        return matches? matches[2] || true : '';
    },

    /**
     * Retrieves a name/value list of modifiers
     * @private
     * @param {Array} [modNames] Names of modifiers
     * @param {Object} [elem] Element
     * @returns {Object} Hash of modifier values by names
     */
    _extractMods : function(modNames, elem) {
        var res = {},
            extractAll = !modNames.length,
            countMatched = 0;

        ((elem || this.domElem)[0].className
            .match(this.__self._buildModValRE(
                '(' + (extractAll? NAME_PATTERN : modNames.join('|')) + ')',
                elem,
                'g')) || []).forEach(function(className) {
                    var matches = className.match(EXTRACT_MODS_RE);
                    res[matches[1]] = matches[2] || true;
                    ++countMatched;
                });

        // empty modifier values are not reflected in classes; they must be filled with empty values
        countMatched < modNames.length && modNames.forEach(function(modName) {
            modName in res || (res[modName] = '');
        });

        return res;
    },

    /**
     * Sets a modifier's CSS class for a block's DOM element or nested element
     * @private
     * @param {String} modName Modifier name
     * @param {String} modVal Modifier value
     * @param {String} oldModVal Old modifier value
     * @param {jQuery} [elem] Element
     * @param {String} [elemName] Element name
     */
    _onSetMod : function(modName, modVal, oldModVal, elem, elemName) {
        if(modName !== 'js' || modVal !== '') {
            var _self = this.__self,
                classPrefix = _self._buildModClassPrefix(modName, elemName),
                classRE = _self._buildModValRE(modName, elemName),
                needDel = modVal === '' || modVal === false;

            (elem || this.domElem).each(function() {
                var className = this.className,
                    modClassName = classPrefix;

                modVal !== true && (modClassName += MOD_DELIM + modVal);

                (oldModVal === true?
                    classRE.test(className) :
                    className.indexOf(classPrefix + MOD_DELIM) > -1)?
                        this.className = className.replace(
                            classRE,
                            (needDel? '' : '$1' + modClassName)) :
                        needDel || $(this).addClass(modClassName);
            });

            elemName && this
                .dropElemCache(elemName, modName, oldModVal)
                .dropElemCache(elemName, modName, modVal);
        }

        this.__base.apply(this, arguments);
    },

    /**
     * Finds elements nested in a block
     * @param {jQuery} [ctx=this.domElem] Element where search is being performed
     * @param {String} names Nested element name (or names separated by spaces)
     * @param {String} [modName] Modifier name
     * @param {String} [modVal] Modifier value
     * @param {Boolean} [strictMode=false]
     * @returns {jQuery} DOM elements
     */
    findElem : function(ctx, names, modName, modVal, strictMode) {
        if(typeof ctx === 'string') {
            strictMode = modVal;
            modVal = modName;
            modName = names;
            names = ctx;
            ctx = this.domElem;
        }

        if(typeof modName === 'boolean') {
            strictMode = modName;
            modName = undef;
        }

        var _self = this.__self,
            selector = '.' +
                names.split(' ').map(function(name) {
                    return _self.buildClass(name, modName, modVal);
                }).join(',.'),
            res = findDomElem(ctx, selector);

        return strictMode? this._filterFindElemResults(res) : res;
    },

    /**
     * Filters results of findElem helper execution in strict mode
     * @param {jQuery} res DOM elements
     * @returns {jQuery} DOM elements
     */
    _filterFindElemResults : function(res) {
        var blockSelector = this.buildSelector(),
            domElem = this.domElem;
        return res.filter(function() {
            return domElem.index($(this).closest(blockSelector)) > -1;
        });
    },

    /**
     * Finds elements nested in a block
     * @private
     * @param {String} name Nested element name
     * @param {String} [modName] Modifier name
     * @param {String} [modVal] Modifier value
     * @returns {jQuery} DOM elements
     */
    _elem : function(name, modName, modVal) {
        var key = name + buildModPostfix(modName, modVal),
            res;

        if(!(res = this._elemCache[key])) {
            res = this._elemCache[key] = this.findElem(name, modName, modVal);
            res.__bemElemName = name;
        }

        return res;
    },

    /**
     * Lazy search for elements nested in a block (caches results)
     * @param {String} names Nested element name (or names separated by spaces)
     * @param {String} [modName] Modifier name
     * @param {String} [modVal] Modifier value
     * @returns {jQuery} DOM elements
     */
    elem : function(names, modName, modVal) {
        if(modName && typeof modName !== 'string') {
            modName.__bemElemName = names;
            return modName;
        }

        if(names.indexOf(' ') < 0) {
            return this._elem(names, modName, modVal);
        }

        var res = $([]);
        names.split(' ').forEach(function(name) {
            res = res.add(this._elem(name, modName, modVal));
        }, this);
        return res;
    },

    /**
     * Finds elements outside the context
     * @param {jQuery} ctx context
     * @param {String} elemName Element name
     * @returns {jQuery} DOM elements
     */
    closestElem : function(ctx, elemName) {
        return ctx.closest(this.buildSelector(elemName));
    },

    /**
     * Clearing the cache for elements
     * @protected
     * @param {String} [names] Nested element name (or names separated by spaces)
     * @param {String} [modName] Modifier name
     * @param {String} [modVal] Modifier value
     * @returns {this}
     */
    dropElemCache : function(names, modName, modVal) {
        if(names) {
            var modPostfix = buildModPostfix(modName, modVal);
            names.indexOf(' ') < 0?
                delete this._elemCache[names + modPostfix] :
                names.split(' ').forEach(function(name) {
                    delete this._elemCache[name + modPostfix];
                }, this);
        } else {
            this._elemCache = {};
        }

        return this;
    },

    /**
     * Retrieves parameters of a block element
     * @param {String|jQuery} elem Element
     * @returns {Object} Parameters
     */
    elemParams : function(elem) {
        var elemName;
        if(typeof elem === 'string') {
            elemName = elem;
            elem = this.elem(elem);
        } else {
            elemName = this.__self._extractElemNameFrom(elem);
        }

        return extractParams(elem[0])[this.__self.buildClass(elemName)] || {};
    },

    /**
     * Elemify given element
     * @param {jQuery} elem Element
     * @param {String} elemName Name
     * @returns {jQuery}
     */
    elemify : function(elem, elemName) {
        (elem = $(elem)).__bemElemName = elemName;
        return elem;
    },

    /**
     * Checks whether a DOM element is in a block
     * @protected
     * @param {jQuery} [ctx=this.domElem] Element where check is being performed
     * @param {jQuery} domElem DOM element
     * @returns {Boolean}
     */
    containsDomElem : function(ctx, domElem) {
        if(arguments.length === 1) {
            domElem = ctx;
            ctx = this.domElem;
        }

        return dom.contains(ctx, domElem);
    },

    /**
     * Builds a CSS selector corresponding to a block/element and modifier
     * @param {String} [elem] Element name
     * @param {String} [modName] Modifier name
     * @param {String} [modVal] Modifier value
     * @returns {String}
     */
    buildSelector : function(elem, modName, modVal) {
        return this.__self.buildSelector(elem, modName, modVal);
    },

    /**
     * Destructs a block
     * @private
     */
    _destruct : function() {
        var _this = this,
            _self = _this.__self;

        _this._needSpecialUnbind && _self.doc.add(_self.win).unbind('.' + _this._uniqId);

        _this.__base();

        delete uniqIdToBlock[_this.un()._uniqId];
    }

}, /** @lends BEMDOM */{

    /**
     * Scope, will be set on onDomReady to `<body>`
     * @type jQuery
     */
    scope : null,

    /**
     * Document shortcut
     * @type jQuery
     */
    doc : doc,

    /**
     * Window shortcut
     * @type jQuery
     */
    win : win,

    /**
     * Processes a block's live properties
     * @private
     * @param {Boolean} [heedLive=false] Whether to take into account that the block already processed its live properties
     * @returns {Boolean} Whether the block is a live block
     */
    _processLive : function(heedLive) {
        var res = this._liveInitable;

        if('live' in this) {
            var noLive = typeof res === 'undefined';

            if(noLive ^ heedLive) {
                res = this.live() !== false;
                this.live = functions.noop;
            }
        }

        return res;
    },

    /**
     * Initializes blocks on a fragment of the DOM tree
     * @param {jQuery|String} [ctx=scope] Root DOM node
     * @returns {jQuery} ctx Initialization context
     */
    init : function(ctx) {
        if(typeof ctx === 'string') ctx = $(ctx);
        else if(!ctx) ctx = DOM.scope;

        var uniqInitId = identify();
        findDomElem(ctx, BEM_SELECTOR).each(function() {
            initBlocks($(this), uniqInitId);
        });

        this._runInitFns();

        return ctx;
    },

    /**
     * Destroys blocks on a fragment of the DOM tree
     * @param {jQuery} ctx Root DOM node
     * @param {Boolean} [excludeSelf=false] Exclude the main domElem
     */
    destruct : function(ctx, excludeSelf) {
        var _ctx;
        if(excludeSelf) {
            storeDomNodeParents(_ctx = ctx.children());
            ctx.empty();
        } else {
            storeDomNodeParents(_ctx = ctx);
            ctx.remove();
        }

        reverse.call(findDomElem(_ctx, BEM_SELECTOR)).each(function(_, domNode) {
            var params = getParams(domNode);
            objects.each(params, function(blockParams) {
                if(blockParams.uniqId) {
                    var block = uniqIdToBlock[blockParams.uniqId];
                    block?
                        removeDomNodeFromBlock(block, domNode) :
                        delete uniqIdToDomElems[blockParams.uniqId];
                }
            });
            delete domElemToParams[identify(domNode)];
        });

        // flush parent nodes storage that has been filled above
        domNodesToParents = {};
    },

    /**
     * Replaces a fragment of the DOM tree inside the context, destroying old blocks and intializing new ones
     * @param {jQuery} ctx Root DOM node
     * @param {jQuery|String} content New content
     * @returns {jQuery} Updated root DOM node
     */
    update : function(ctx, content) {
        this.destruct(ctx, true);
        return this.init(ctx.html(content));
    },

    /**
     * Changes a fragment of the DOM tree including the context and initializes blocks.
     * @param {jQuery} ctx Root DOM node
     * @param {jQuery|String} content Content to be added
     * @returns {jQuery} New content
     */
    replace : function(ctx, content) {
        var prev = ctx.prev(),
            parent = ctx.parent();

        this.destruct(ctx);

        return this.init(prev.length?
            $(content).insertAfter(prev) :
            $(content).prependTo(parent));
    },

    /**
     * Adds a fragment of the DOM tree at the end of the context and initializes blocks
     * @param {jQuery} ctx Root DOM node
     * @param {jQuery|String} content Content to be added
     * @returns {jQuery} New content
     */
    append : function(ctx, content) {
        return this.init($(content).appendTo(ctx));
    },

    /**
     * Adds a fragment of the DOM tree at the beginning of the context and initializes blocks
     * @param {jQuery} ctx Root DOM node
     * @param {jQuery|String} content Content to be added
     * @returns {jQuery} New content
     */
    prepend : function(ctx, content) {
        return this.init($(content).prependTo(ctx));
    },

    /**
     * Adds a fragment of the DOM tree before the context and initializes blocks
     * @param {jQuery} ctx Contextual DOM node
     * @param {jQuery|String} content Content to be added
     * @returns {jQuery} New content
     */
    before : function(ctx, content) {
        return this.init($(content).insertBefore(ctx));
    },

    /**
     * Adds a fragment of the DOM tree after the context and initializes blocks
     * @param {jQuery} ctx Contextual DOM node
     * @param {jQuery|String} content Content to be added
     * @returns {jQuery} New content
     */
    after : function(ctx, content) {
        return this.init($(content).insertAfter(ctx));
    },

    /**
     * Builds a full name for a live event
     * @private
     * @param {String} e Event name
     * @returns {String}
     */
    _buildCtxEventName : function(e) {
        return this._name + ':' + e;
    },

    _liveClassBind : function(className, e, callback, invokeOnInit) {
        if(e.indexOf(' ') > -1) {
            e.split(' ').forEach(function(e) {
                this._liveClassBind(className, e, callback, invokeOnInit);
            }, this);
        } else {
            var storage = liveClassEventStorage[e],
                uniqId = identify(callback);

            if(!storage) {
                storage = liveClassEventStorage[e] = {};
                DOM.scope.bind(e, $.proxy(this._liveClassTrigger, this));
            }

            storage = storage[className] || (storage[className] = { uniqIds : {}, fns : [] });

            if(!(uniqId in storage.uniqIds)) {
                storage.fns.push({ uniqId : uniqId, fn : this._buildLiveEventFn(callback, invokeOnInit) });
                storage.uniqIds[uniqId] = storage.fns.length - 1;
            }
        }

        return this;
    },

    _liveClassUnbind : function(className, e, callback) {
        var storage = liveClassEventStorage[e];
        if(storage) {
            if(callback) {
                if(storage = storage[className]) {
                    var uniqId = identify(callback);
                    if(uniqId in storage.uniqIds) {
                        var i = storage.uniqIds[uniqId],
                            len = storage.fns.length - 1;
                        storage.fns.splice(i, 1);
                        while(i < len) storage.uniqIds[storage.fns[i++].uniqId] = i - 1;
                        delete storage.uniqIds[uniqId];
                    }
                }
            } else {
                delete storage[className];
            }
        }

        return this;
    },

    _liveClassTrigger : function(e) {
        var storage = liveClassEventStorage[e.type];
        if(storage) {
            var node = e.target, classNames = [];
            for(var className in storage) {
                classNames.push(className);
            }
            do {
                var nodeClassName = ' ' + node.className + ' ', i = 0;
                while(className = classNames[i++]) {
                    if(nodeClassName.indexOf(' ' + className + ' ') > -1) {
                        var j = 0, fns = storage[className].fns, fn, stopPropagationAndPreventDefault = false;
                        while(fn = fns[j++])
                            if(fn.fn.call($(node), e) === false) stopPropagationAndPreventDefault = true;

                        stopPropagationAndPreventDefault && e.preventDefault();
                        if(stopPropagationAndPreventDefault || e.isPropagationStopped()) return;

                        classNames.splice(--i, 1);
                    }
                }
            } while(classNames.length && (node = node.parentNode));
        }
    },

    _buildLiveEventFn : function(callback, invokeOnInit) {
        var _this = this;
        return function(e) {
            e.currentTarget = this;
            var args = [
                    _this._name,
                    $(this).closest(_this.buildSelector()),
                    undef,
                    true
                ],
                block = initBlock.apply(null, invokeOnInit? args.concat([callback, e]) : args);

            if(block && !invokeOnInit && callback)
                return callback.apply(block, arguments);
        };
    },

    /**
     * Helper for live initialization for an event on DOM elements of a block or its elements
     * @protected
     * @param {String} [elemName] Element name or names (separated by spaces)
     * @param {String} event Event name
     * @param {Function} [callback] Handler to call after successful initialization
     */
    liveInitOnEvent : function(elemName, event, callback) {
        return this.liveBindTo(elemName, event, callback, true);
    },

    /**
     * Helper for subscribing to live events on DOM elements of a block or its elements
     * @protected
     * @param {String|Object} [to] Description (object with modName, modVal, elem) or name of the element or elements (space-separated)
     * @param {String} event Event name
     * @param {Function} [callback] Handler
     */
    liveBindTo : function(to, event, callback, invokeOnInit) {
        if(!event || functions.isFunction(event)) {
            callback = event;
            event = to;
            to = undef;
        }

        if(!to || typeof to === 'string') {
            to = { elem : to };
        }

        if(to.elem && to.elem.indexOf(' ') > 0) {
            to.elem.split(' ').forEach(function(elem) {
                this._liveClassBind(
                    this.buildClass(elem, to.modName, to.modVal),
                    event,
                    callback,
                    invokeOnInit);
            }, this);
            return this;
        }

        return this._liveClassBind(
            this.buildClass(to.elem, to.modName, to.modVal),
            event,
            callback,
            invokeOnInit);
    },

    /**
     * Helper for unsubscribing from live events on DOM elements of a block or its elements
     * @protected
     * @param {String} [elem] Name of the element or elements (space-separated)
     * @param {String} event Event name
     * @param {Function} [callback] Handler
     */
    liveUnbindFrom : function(elem, event, callback) {

        if(!event || functions.isFunction(event)) {
            callback = event;
            event = elem;
            elem = undef;
        }

        if(elem && elem.indexOf(' ') > 1) {
            elem.split(' ').forEach(function(elem) {
                this._liveClassUnbind(
                    this.buildClass(elem),
                    event,
                    callback);
            }, this);
            return this;
        }

        return this._liveClassUnbind(
            this.buildClass(elem),
            event,
            callback);
    },

    /**
     * Helper for live initialization when a different block is initialized
     * @private
     * @param {String} event Event name
     * @param {String} blockName Name of the block that should trigger a reaction when initialized
     * @param {Function} callback Handler to be called after successful initialization in the new block's context
     * @param {String} findFnName Name of the method for searching
     */
    _liveInitOnBlockEvent : function(event, blockName, callback, findFnName) {
        var name = this._name;
        blocks[blockName].on(event, function(e) {
            var args = arguments,
                blocks = e.target[findFnName](name);

            callback && blocks.forEach(function(block) {
                callback.apply(block, args);
            });
        });
        return this;
    },

    /**
     * Helper for live initialization for a different block's event on the current block's DOM element
     * @protected
     * @param {String} event Event name
     * @param {String} blockName Name of the block that should trigger a reaction when initialized
     * @param {Function} callback Handler to be called after successful initialization in the new block's context
     */
    liveInitOnBlockEvent : function(event, blockName, callback) {
        return this._liveInitOnBlockEvent(event, blockName, callback, 'findBlocksOn');
    },

    /**
     * Helper for live initialization for a different block's event inside the current block
     * @protected
     * @param {String} event Event name
     * @param {String} blockName Name of the block that should trigger a reaction when initialized
     * @param {Function} [callback] Handler to be called after successful initialization in the new block's context
     */
    liveInitOnBlockInsideEvent : function(event, blockName, callback) {
        return this._liveInitOnBlockEvent(event, blockName, callback, 'findBlocksOutside');
    },

    /**
     * Adds a live event handler to a block, based on a specified element where the event will be listened for
     * @param {jQuery} [ctx] The element in which the event will be listened for
     * @param {String} e Event name
     * @param {Object} [data] Additional information that the handler gets as e.data
     * @param {Function} fn Handler
     * @param {Object} [fnCtx] Handler's context
     */
    on : function(ctx, e, data, fn, fnCtx) {
        return typeof ctx === 'object' && ctx.jquery?
            this._liveCtxBind(ctx, e, data, fn, fnCtx) :
            this.__base(ctx, e, data, fn);
    },

    /**
     * Removes the live event handler from a block, based on a specified element where the event was being listened for
     * @param {jQuery} [ctx] The element in which the event was being listened for
     * @param {String} e Event name
     * @param {Function} [fn] Handler
     * @param {Object} [fnCtx] Handler context
     */
    un : function(ctx, e, fn, fnCtx) {
        return typeof ctx === 'object' && ctx.jquery?
            this._liveCtxUnbind(ctx, e, fn, fnCtx) :
            this.__base(ctx, e, fn);
    },

    /**
     * Adds a live event handler to a block, based on a specified element where the event will be listened for
     * @private
     * @param {jQuery} ctx The element in which the event will be listened for
     * @param {String} e  Event name
     * @param {Object} [data] Additional information that the handler gets as e.data
     * @param {Function} fn Handler
     * @param {Object} [fnCtx] Handler context
     * @returns {this}
     */
    _liveCtxBind : function(ctx, e, data, fn, fnCtx) {
        if(typeof e === 'object') {
            if(functions.isFunction(data) || functions.isFunction(fn)) { // mod change event
                e = this._buildModEventName(e);
            } else {
                objects.each(e, function(fn, e) {
                    this._liveCtxBind(ctx, e, fn, data);
                }, this);
                return this;
            }
        }

        if(functions.isFunction(data)) {
            fnCtx = fn;
            fn = data;
            data = undef;
        }

        if(e.indexOf(' ') > -1) {
            e.split(' ').forEach(function(e) {
                this._liveCtxBind(ctx, e, data, fn, fnCtx);
            }, this);
        } else {
            var ctxE = this._buildCtxEventName(e),
                storage = liveEventCtxStorage[ctxE] ||
                    (liveEventCtxStorage[ctxE] = { counter : 0, ctxs : {} });

            ctx.each(function() {
                var ctxId = identify(this),
                    ctxStorage = storage.ctxs[ctxId];
                if(!ctxStorage) {
                    ctxStorage = storage.ctxs[ctxId] = {};
                    ++storage.counter;
                }
                ctxStorage[identify(fn) + (fnCtx? identify(fnCtx) : '')] = {
                    fn : fn,
                    data : data,
                    ctx : fnCtx
                };
            });
        }

        return this;
    },

    /**
     * Removes a live event handler from a block, based on a specified element where the event was being listened for
     * @private
     * @param {jQuery} ctx The element in which the event was being listened for
     * @param {String|Object} e Event name
     * @param {Function} [fn] Handler
     * @param {Object} [fnCtx] Handler context
     */
    _liveCtxUnbind : function(ctx, e, fn, fnCtx) {
        if(typeof e === 'object' && functions.isFunction(fn)) { // mod change event
            e = this._buildModEventName(e);
        }

        var storage = liveEventCtxStorage[e = this._buildCtxEventName(e)];

        if(storage) {
            ctx.each(function() {
                var ctxId = identify(this, true),
                    ctxStorage;
                if(ctxId && (ctxStorage = storage.ctxs[ctxId])) {
                    fn && delete ctxStorage[identify(fn) + (fnCtx? identify(fnCtx) : '')];
                    if(!fn || objects.isEmpty(ctxStorage)) {
                        storage.counter--;
                        delete storage.ctxs[ctxId];
                    }
                }
            });
            storage.counter || delete liveEventCtxStorage[e];
        }

        return this;
    },

    /**
     * Retrieves the name of an element nested in a block
     * @private
     * @param {jQuery} elem Nested element
     * @returns {String|undef}
     */
    _extractElemNameFrom : function(elem) {
        if(elem.__bemElemName) return elem.__bemElemName;

        var matches = elem[0].className.match(this._buildElemNameRE());
        return matches? matches[1] : undef;
    },

    /**
     * Builds a prefix for the CSS class of a DOM element or nested element of the block, based on modifier name
     * @private
     * @param {String} modName Modifier name
     * @param {jQuery|String} [elem] Element
     * @returns {String}
     */
    _buildModClassPrefix : function(modName, elem) {
        return this._name +
               (elem?
                   ELEM_DELIM + (typeof elem === 'string'? elem : this._extractElemNameFrom(elem)) :
                   '') +
               MOD_DELIM + modName;
    },

    /**
     * Builds a regular expression for extracting modifier values from a DOM element or nested element of a block
     * @private
     * @param {String} modName Modifier name
     * @param {jQuery|String} [elem] Element
     * @param {String} [quantifiers] Regular expression quantifiers
     * @returns {RegExp}
     */
    _buildModValRE : function(modName, elem, quantifiers) {
        return new RegExp(
            '(\\s|^)' +
            this._buildModClassPrefix(modName, elem) +
            '(?:' + MOD_DELIM + '(' + NAME_PATTERN + '))?(?=\\s|$)',
            quantifiers);
    },

    /**
     * Builds a regular expression for extracting names of elements nested in a block
     * @private
     * @returns {RegExp}
     */
    _buildElemNameRE : function() {
        return new RegExp(this._name + ELEM_DELIM + '(' + NAME_PATTERN + ')(?:\\s|$)');
    },

    /**
     * Builds a CSS class corresponding to the block/element and modifier
     * @param {String} [elem] Element name
     * @param {String} [modName] Modifier name
     * @param {String} [modVal] Modifier value
     * @returns {String}
     */
    buildClass : function(elem, modName, modVal) {
        return buildClass(this._name, elem, modName, modVal);
    },

    /**
     * Builds a CSS selector corresponding to the block/element and modifier
     * @param {String} [elem] Element name
     * @param {String} [modName] Modifier name
     * @param {String} [modVal] Modifier value
     * @returns {String}
     */
    buildSelector : function(elem, modName, modVal) {
        return '.' + this.buildClass(elem, modName, modVal);
    }
});

/**
 * Returns a block on a DOM element and initializes it if necessary
 * @param {String} blockName Block name
 * @param {Object} params Block parameters
 * @returns {BEMDOM}
 */
$.fn.bem = function(blockName, params) {
    return initBlock(blockName, this, params, true);
};

// Set default scope after DOM ready
$(function() {
    DOM.scope = $('body');
});

provide(DOM);

});

(function() {

var origDefine = modules.define;

modules.define = function(name, deps, decl) {
    origDefine.apply(modules, arguments);

    name !== 'i-bem__dom_init' && arguments.length > 2 && ~deps.indexOf('i-bem__dom') &&
        modules.define('i-bem__dom_init', [name], function(provide, _, prev) {
            provide(prev);
        });
};

})();

/* ../../libs/bem-core/common.blocks/i-bem/__dom/i-bem__dom.js end */
;
/* ../../libs/bem-core/common.blocks/jquery/jquery.js begin */
/**
 * @module jquery
 * @description Provide jQuery (load if it does not exist).
 */

modules.define(
    'jquery',
    ['loader_type_js', 'jquery__config'],
    function(provide, loader, cfg) {

/* global jQuery */

function doProvide(preserveGlobal) {
    /**
     * @exports
     * @type Function
     */
    provide(preserveGlobal? jQuery : jQuery.noConflict(true));
}

typeof jQuery !== 'undefined'?
    doProvide(true) :
    loader(cfg.url, doProvide);
});

/* ../../libs/bem-core/common.blocks/jquery/jquery.js end */
;
/* ../../libs/bem-core/common.blocks/loader/_type/loader_type_js.js begin */
/**
 * @module loader_type_js
 * @description Load JS from external URL.
 */

modules.define('loader_type_js', function(provide) {

var loading = {},
    loaded = {},
    head = document.getElementsByTagName('head')[0],
    onLoad = function(path) {
        loaded[path] = true;
        var cbs = loading[path], cb, i = 0;
        delete loading[path];
        while(cb = cbs[i++]) {
            cb();
        }
    };

provide(
    /**
     * @exports
     * @param {String} path resource link
     * @param {Function} callback executes when resource is loaded
     */
    function(path, cb) {
        if(loaded[path]) {
            cb();
            return;
        }

        if(loading[path]) {
            loading[path].push(cb);
            return;
        }

        loading[path] = [cb];

        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.charset = 'utf-8';
        script.src = (location.protocol === 'file:' && !path.indexOf('//')? 'http:' : '') + path;
        script.onreadystatechange === null?
            script.onreadystatechange = function() {
                var readyState = this.readyState;
                if(readyState === 'loaded' || readyState === 'complete') {
                    script.onreadystatechange = null;
                    onLoad(path);
                }
            } :
            script.onload = script.onerror = function() {
                script.onload = script.onerror = null;
                onLoad(path);
            };

        head.insertBefore(script, head.lastChild);
    }
);

});

/* ../../libs/bem-core/common.blocks/loader/_type/loader_type_js.js end */
;
/* ../../libs/bem-core/common.blocks/jquery/__config/jquery__config.js begin */
/**
 * @module jquery__config
 * @description Configuration for jQuery
 */

modules.define('jquery__config', function(provide) {

provide(/** @exports */{
    /**
     * URL for loading jQuery if it does not exist
     */
    url : '//yastatic.net/jquery/2.1.1/jquery.min.js'
});

});

/* ../../libs/bem-core/common.blocks/jquery/__config/jquery__config.js end */
;
/* ../../libs/bem-core/desktop.blocks/jquery/__config/jquery__config.js begin */
/**
 * @module jquery__config
 * @description Configuration for jQuery
 */

modules.define(
    'jquery__config',
    ['ua', 'objects'],
    function(provide, ua, objects, base) {

provide(
    ua.msie && parseInt(ua.version, 10) < 9?
        objects.extend(
            base,
            {
                url : '//yastatic.net/jquery/1.11.1/jquery.min.js'
            }) :
        base);

});

/* ../../libs/bem-core/desktop.blocks/jquery/__config/jquery__config.js end */
;
/* ../../libs/bem-core/desktop.blocks/ua/ua.js begin */
/** 
 * @module ua
 * @description Detect some user agent features (works like jQuery.browser in jQuery 1.8)
 * @see http://code.jquery.com/jquery-migrate-1.1.1.js
 */

modules.define('ua', function(provide) {

var ua = navigator.userAgent.toLowerCase(),
    match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
        /(webkit)[ \/]([\w.]+)/.exec(ua) ||
        /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
        /(msie) ([\w.]+)/.exec(ua) ||
        ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
        [],
    matched = {
        browser : match[1] || '',
        version : match[2] || '0'
    },
    browser = {};

if(matched.browser) {
    browser[matched.browser] = true;
    browser.version = matched.version;
}

if(browser.chrome) {
    browser.webkit = true;
} else if(browser.webkit) {
    browser.safari = true;
}

/**
 * @exports
 * @type Object
 */
provide(browser);

});

/* ../../libs/bem-core/desktop.blocks/ua/ua.js end */
;
/* ../../libs/bem-core/common.blocks/dom/dom.js begin */
/**
 * @module dom
 * @description some DOM utils
 */

modules.define('dom', ['jquery'], function(provide, $) {

provide(/** @exports */{
    /**
     * Checks whether a DOM elem is in a context
     * @param {jQuery} ctx DOM elem where check is being performed
     * @param {jQuery} domElem DOM elem to check
     * @returns {Boolean}
     */
    contains : function(ctx, domElem) {
        var res = false;

        domElem.each(function() {
            var domNode = this;
            do {
                if(~ctx.index(domNode)) return !(res = true);
            } while(domNode = domNode.parentNode);

            return res;
        });

        return res;
    },

    /**
     * Returns current focused DOM elem in document
     * @returns {jQuery}
     */
    getFocused : function() {
        // "Error: Unspecified error." in iframe in IE9
        try { return $(document.activeElement); } catch(e) {}
    },

    /**
     * Checks whether a DOM element contains focus
     * @param {jQuery} domElem
     * @returns {Boolean}
     */
    containsFocus : function(domElem) {
        return this.contains(domElem, this.getFocused());
    },

    /**
    * Checks whether a browser currently can set focus on DOM elem
    * @param {jQuery} domElem
    * @returns {Boolean}
    */
    isFocusable : function(domElem) {
        var domNode = domElem[0];

        if(!domNode) return false;
        if(domNode.hasAttribute('tabindex')) return true;

        switch(domNode.tagName.toLowerCase()) {
            case 'iframe':
                return true;

            case 'input':
            case 'button':
            case 'textarea':
            case 'select':
                return !domNode.disabled;

            case 'a':
                return !!domNode.href;
        }

        return false;
    },

    /**
    * Checks whether a domElem is intended to edit text
    * @param {jQuery} domElem
    * @returns {Boolean}
    */
    isEditable : function(domElem) {
        var domNode = domElem[0];

        if(!domNode) return false;

        switch(domNode.tagName.toLowerCase()) {
            case 'input':
                var type = domNode.type;
                return (type === 'text' || type === 'password') && !domNode.disabled && !domNode.readOnly;

            case 'textarea':
                return !domNode.disabled && !domNode.readOnly;

            default:
                return domNode.contentEditable === 'true';
        }
    }
});

});

/* ../../libs/bem-core/common.blocks/dom/dom.js end */
;
/* ../../libs/bem-core/common.blocks/i-bem/__dom/_init/i-bem__dom_init.js begin */
/**
 * @module i-bem__dom_init
 */

modules.define('i-bem__dom_init', ['i-bem__dom'], function(provide, BEMDOM) {

provide(
    /**
     * Initializes blocks on a fragment of the DOM tree
     * @exports
     * @param {jQuery} [ctx=scope] Root DOM node
     * @returns {jQuery} ctx Initialization context
     */
    function(ctx) {
        return BEMDOM.init(ctx);
    });
});

/* ../../libs/bem-core/common.blocks/i-bem/__dom/_init/i-bem__dom_init.js end */
;
/* ../../libs/bem-core/common.blocks/i-bem/__dom/_init/i-bem__dom_init_auto.js begin */
/**
 * Auto initialization on DOM ready
 */

modules.require(
    ['i-bem__dom_init', 'jquery', 'next-tick'],
    function(init, $, nextTick) {

$(function() {
    nextTick(init);
});

});

/* ../../libs/bem-core/common.blocks/i-bem/__dom/_init/i-bem__dom_init_auto.js end */
;
/* ../../desktop.blocks/app/app.js begin */
modules.define('app', ['i-bem__dom', 'keyboard__codes'], function(provide, BEMDOM, KEYS) {

    BEMDOM.decl(this.name, {
        
        onSetMod: {
            'js': {
                'inited': function() {
                    var card = this.findBlockInside('card');
                    this.bindTo('keyup', function(e) {
                        if(e.which === KEYS.SPACE || e.which == KEYS.ENTER) {
                            card.flip();
                        }
                    });
                }
            }
        }
        
    });

    provide(BEMDOM);

});

/* ../../desktop.blocks/app/app.js end */
;
/* ../../desktop.blocks/card/card.js begin */
modules.define('card', ['dict', 'location', 'strings__escape', 'i-bem__dom'], function(provide, dict, location, escape, BEMDOM) {

    BEMDOM.decl(this.name, {
        
        onSetMod: {
            'js': {
                'inited': function() {
                    location.on('change', this._onLocationChange, this);
                    this.bindTo('click', this._onClick);
                    
                    this._getWord();
                    
                    if (!this.word) {
                        this._next(true);
                    } else {
                        this.setMod('status', 'showed');
                    }
                }
            },
            
            'status': {
                'showed': function() {
                    this.elem('word').html(escape.html(this.word) + '<br>' + dict.transcript(this.word));
                },

                'translated': function() {
                    this.elem('translation').text(dict.translate(this.word));
                }
            }
        },
        
        _getWord: function() {
            this.word = (location.getState().params['w'] || [])[0];
        },
        
        _next: function(replace) {
            location.change({ params: { w: dict.random(this.word) }, replace: replace });
        },
        
        _onClick: function() {
            this.flip();
        },
        
        _onLocationChange: function() {
            this._getWord();
            this
                .delMod('status')
                .setMod('status', 'showed');
        },
        
        flip: function() {
            switch (this.getMod('status')) {
                case 'showed':
                    this.setMod('status', 'translated');
                break;
                default:
                    this._next();
            }
        }
        
    });

    provide(BEMDOM);

});

/* ../../desktop.blocks/card/card.js end */
;
/* ../../libs/bem-history/common.blocks/location/location.js begin */
/**
 * @module location
 */
modules.define(
    'location',
    ['inherit', 'events', 'history', 'objects', 'uri'],
    function(provide, inherit, events, History, objects, Uri) {

/**
 * @class BEMLocation
 * @augments events:Emitter
 */
var BEMLocation = inherit(events.Emitter, {
    /**
     * @constructor
     */
    __constructor : function() {
        this._history = new History();

        this._syncState();
        this._history.on('statechange', this._onStateChange, this);
    },

    /**
     * Reaction for the history state change.
     * @param {Object} event
     * @param {Object} event params
     */
    _onStateChange : function() {
        this._syncState();

        // Some browsers (like Chromium v36) emit "popstate" event when you return from other site
        // using back/forward buttons. But some doesn't (like FireFox v28).
        // We don't want to track this "popstate" event like location change.
        if(this._state.referer === Uri.normalize(window.location.href)) return;

        if(this._state.silent !== true) {
            this.emit('change', this._state);
        }
    },

    /**
     * Sync own state with the history block state.
     * @returns {Object} location
     * @private
     */
    _syncState : function() {
        var state = this._history.state,
            uri = Uri.parse(state.url);

        this._state = objects.extend(state.data, {
            referer : this._state && this._state.url, // referer - previous url
            url : uri.build(),                        // full page URL –
            // http://yandex.ru/yandsearch?text=ololo&lr=213
            hostname : uri.getHost(),                 // page hostname - yandex.ru
            path : uri.getPath(),                     // path to the current page - /yandsearch
            params : uri.getParams()                  // search params –
            // { text: ['ololo'], lr: ['213'] }
        });

        return this;
    },

    /**
     * Method for a location change. It's possible to change location
     * by an exact url or a query params (params can be overwritten using the forceParams flag).
     * Method work depends on the provided data.
     * @param {Object} data
     * @param {Object} data.params query params
     * @param {String} data.url new url
     * @param {Boolean} [data.silent = false] do not trigger change event
     * @param {Boolean} data.forceParams flag to overwrite current params with new. 
     *                                   By default new params are extended with old
     * @param {Boolean} data.replace write history record or replace current
     */
    change : function(data) {
        var uri = Uri.parse(data.url);

        if(data.url) {
            delete data.params;
        }

        data.url = uri.build();

        // Build a new url if the query params exists in data
        if(data.params) {
            var newUrl = new Uri(),
                params = data.forceParams ? data.params : objects.extend({}, this._state.params, data.params);

            objects.each(params, function(value, key) {
                newUrl.addParam(key, value);
            });
            data.url = newUrl.build();
        }

        // By default trigger change event
        data.silent || (data.silent = false);

        try {
            this._history.changeState(
                (data.replace ? 'replace' : 'push'),
                data
            );
        } catch (e) {
            window.location.assign(data.url);
        }
    },

    /**
     * Returns current state.
     * @returns {Object} state
     */
    getState : function() {
        return objects.extend({}, this._state);
    },

    /**
     * Returns an Uri instance constructed from the current state url.
     * @returns {uri}
     */
    getUri : function() {
        return Uri.parse(this._state.url);
    },

    /**
     * Returns previous url.
     * @returns {String} refererUrl
     */
    getReferer : function() {
        return this._state.referer;
    }

});

provide(new BEMLocation());

});

/* ../../libs/bem-history/common.blocks/location/location.js end */
;
/* ../../libs/bem-history/common.blocks/history/history.js begin */
/**
 * BEM wrap for History API.
 * @module history
 */
modules.define('history', ['inherit', 'events', 'jquery', 'uri'], function(provide, inherit, events, $, Uri) {

/**
 * @class BEMHistory
 * @augments events:Emitter
 */
var BEMHistory = inherit(events.Emitter, {
    /**
     * @constructor
     */
    __constructor : function() {
        this
            ._resetUrl()
            ._bindEvents()
            ._syncState();
    },

    /**
     * Adds new state to browsing history.
     *
     * @param {Object} data New state data.
     * @param {String} title Document title.
     * @param {String} [url] Location url.
     * @returns {Object}
     */
    pushState : function(data, title, url) {
        return this.changeState('push', this._normalizeState(data, title, url));
    },

    /**
     * Replaces current state.
     *
     * @param {Object} data New state data
     * @param {String} title Document title.
     * @param {String} [url] Location url.
     * @returns {Object}
     */
    replaceState : function(data, title, url) {
        return this.changeState('replace', this._normalizeState(data, title, url));
    },

    /**
     * Base method for an events binding.
     * Method have to be extended in modificators.
     *
     * @returns {Object}
     */
    _bindEvents : function() {
        return this;
    },

    /**
     * Base method for url check and reset.
     * Method have to be extended in modificators.
     *
     * @returns {Object}
     */
    _resetUrl : function() {
        return this;
    },

    /**
     * Removes hashbang from url.
     * /?p=1#!/?p=2 => /?p=2.
     *
     * @param {String} url
     * @returns {String}
     */
    _removeHashbang : function(url) {
        var parsedUri = Uri.parse(url);

        if(parsedUri.getAnchor() === '') { return url; }
        var hashbangUri = Uri.parse(parsedUri.getAnchor().replace(/^!/, ''));

        parsedUri
            .setAnchor('')
            .setQuery(hashbangUri.getQuery());

        return parsedUri.build();
    },

    /**
     * Base method for the state syncing with global history state.
     * Method may be extended in modificators.
     *
     * @returns {Object}
     */
    _syncState : function() {
        this.state = this._normalizeState(undefined, document.title, window.location.href);
        return this;
    },

    /**
     * Normalizes state to the appropriate form.
     *
     * @param {Object} data
     * @param {String} title
     * @param {String} url
     * @returns {Object} normalized state
     */
    _normalizeState : function(data, title, url) {
        // null -> default state, which we don't want to listen
        // so that data have to be undefined or an empty object
        // but not null
        return {
            data : data === null ? undefined : data,
            title : title,
            url : url
        };
    },

    /**
     * Changes current state.
     * By default it performs simple page redirect.
     * Method may be extended in modificators.
     *
     * @param {String} method Push or Replace method.
     * @param {Object} state
     * @returns {Object}
     */
    changeState : function(method, state) {
        try {
            window.location.assign(state.url);
        } catch (e) {}
    }

});

BEMHistory.hasNativeAPI = function() {
    return (window.history && 'pushState' in window.history);
};

provide(BEMHistory);

});

/* ../../libs/bem-history/common.blocks/history/history.js end */
;
/* ../../libs/bem-history/touch.blocks/history/history.js begin */
modules.define('history', ['inherit', 'jquery', 'uri'], function(provide, inherit, $, Uri, Base) {

Base.hasNativeAPI = function() {
    var result = (window.history && 'pushState' in window.history);

    if(result) {
        var ua = navigator.userAgent,
            android = ua && ua.match(/Android\s*([\d\.]*)/),
            version = android && android[1];

        // Don't allow Androids with versions less than 3 and without version
        // to use native History API due to buggy realisation.
        if(android && (parseFloat(version) < 3 || !version)) {
            result = false;
        }
    }

    return result;
};

provide(Base);

});

/* ../../libs/bem-history/touch.blocks/history/history.js end */
;
/* ../../libs/bem-history/common.blocks/uri/uri.js begin */
/*!
 * Library for uri parsing and changing.
 * Based on jsUri but mostly refactored and rewritten
 *
 * Includes parts of jsUri
 * https://github.com/derek-watson/jsUri
 * Copyright 2012, Derek Watson
 * Released under the MIT license.
 *
 * Includes parseUri regular expressions
 * http://blog.stevenlevithan.com/archives/parseuri
 * Copyright 2007, Steven Levithan
 * Released under the MIT license.
 */

/* jshint maxlen:170 */

/**
 * @module uri
 */
modules.define('uri', ['querystring__uri'], function(provide, decoder) {

/**
 * Creates a new Uri object.
 * @constructor
 * @param {String} str
 */
function Uri(str) {
    this.uriParts = this.parseUri(str);
    this.queryParams = this.parseQuery(this.normalize(this.uriParts.query));
}

/**
 * Parse string and return Uri instance.
 * @param {String} str
 * @returns {Uri}  Uri instance
 */
Uri.parse = function(str) {
    return new Uri(str);
};

/**
 * Normalizes a full url to percentage encoding.
 * @param  {String}  str input url
 * @returns {String}
 */
Uri.normalize = function(str) {
    return Uri.parse(str).toString();
};

/**
 * Encode string.
 * @param  {String} str raw string
 * @returns {String}    encoded string
 */
Uri.prototype.encode = function(str) {
    return encodeURIComponent(str);
};

/**
 * Decode string.
 * @param  {String} str encoded string
 * @returns {String}    original string
 */
Uri.prototype.decode = function(str) {
    return decoder.decodeURIComponent(str);
};

/**
 * Normalizes url string to percentage encoding.
 * @param  {String} str original url
 * @returns {String}    normalized string
 */
Uri.prototype.normalize = function(str) {
    return (str || '').replace(/\+/g, '%20');
};

/**
* Breaks a uri string down into its individual parts.
* @param  {String} str uri
* @returns {Object}    parts
*/
Uri.prototype.parseUri = function(str) {
    /*
    DO NOT split parser regex into parts because it can seriously affect performance!
    jsHint maxlen changed to fix maxlength warning at this line.
    */
    var parser = /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        parserKeys = ['source', 'protocol', 'authority',
                      'userInfo', 'user', 'password', 'host', 'port',
                      'relative', 'path', 'directory', 'file', 'query', 'anchor'],
        m = parser.exec(str || ''),
        parts = {};

    parserKeys.forEach(function(key, i) {
        parts[key] = m[i] || '';
    });

    return parts;
};

/**
 * Breaks a query string down into an array of key/value pairs.
 * ?param=11 -> { param: ['11'] }
 * ?param=   -> { param: [''] }
 * ?param    -> { param: [] }
 * @param  {String} str query
 * @returns {Array}     array of arrays (key/value pairs)
 */
Uri.prototype.parseQuery = function parseQuery(str) {
    var i, ps, kvp, k, v,
        params = {};

    if(typeof str !== 'string' || str === '') {
        return params;
    }

    ps = str.replace('?', '').split('&');

    for(i = 0; i < ps.length; i++) {
        // Split only by first occurrence of =
        kvp = ps[i].split('=');
        kvp = [kvp.shift(), kvp[0] !== undefined ? kvp.join('=') : null];

        k = this.decode(kvp[0]);
        v = (kvp[1] || kvp[1] === '') ? this.decode(kvp[1]) : null;

        if(params[k]) {
            (v || v === '') && params[k].push(v);
        } else {
            params[k] = (v === null) ? [] : [v];
        }
    }
    return params;
};

/**
 * Define getter/setter methods.
 */
['Protocol', 'Host', 'Port', 'Path', 'Anchor'].forEach(function(key) {
    Uri.prototype['get' + key] = function(val) {
        return this.uriParts[key.toLowerCase()];
    };

    Uri.prototype['set' + key] = function(val) {
        this.uriParts[key.toLowerCase()] = val;
        return this;
    };
});

/**
 * Returns an object of query params.
 * @returns {Object}
 */
Uri.prototype.getParams = function(val) {
    return this.queryParams;
};

/**
 * Serializes the internal state of the query pairs.
 * @returns {String}       query string
 */
Uri.prototype.getQuery = function(val) {
    var s = '',
        params = this.queryParams,
        queryKeys = Object.keys(params),
        _this = this;

    queryKeys.forEach(function(key, index) {
        if(index > 0) {
            s += '&';
        }
        if(typeof params[key] === 'object' && !params[key].length) {
            s += key;
        } else {
            params[key].forEach(function(v, i) {
                if(i > 0) {
                    s += '&';
                }
                s += _this.encode(key) + '=' + _this.encode(v);
            });
        }
    });

    return s.length > 0 ? '?' + s : s;
};

/**
 * Url query setter.
 * @param  {String} [val] set a new query string
 * @returns {uri}
 */
Uri.prototype.setQuery = function(val) {
    if(typeof val !== 'undefined') {
        this.queryParams = this.parseQuery(val);
    }

    return this;
};

/**
 * Returns an array of query param values for the key.
 * @param  {String} key query key
 * @returns {Array}     array of values
 */
Uri.prototype.getParam = function(key) {
    return this.queryParams[key];
};

/**
 * Removes query parameters.
 * @param  {String} key     remove values for key
 * @param  {val}    [val]   remove a specific value, otherwise removes all
 * @returns {uri}           returns self for fluent chaining
 */
Uri.prototype.deleteParam = function(key, val) {
    var newParams = [];

    if(typeof val !== 'undefined') {
        this.queryParams[key].forEach(function(paramValue) {
            if(paramValue !== val) {
                newParams.push(paramValue);
            }
        });
        this.queryParams[key] = newParams;
    }

    if(typeof val === 'undefined' || newParams.length === 0) {
        delete this.queryParams[key];
    }

    return this;
};

/**
 * Adds a query parameter.
 * @param  {String}  key        add values for key
 * @param  {String}  val        value to add
 * @returns {uri}               returns self for fluent chaining
 */
Uri.prototype.addParam = function(key, val) {
    this.queryParams[key] = (this.queryParams[key] || []).concat(val);

    return this;
};

/**
 * Replaces query param values.
 * @param  {String} key         key to replace value for
 * @param  {String} newVal      new value
 * @param  {String} [oldVal]    replace only one specific value (otherwise replaces all)
 * @returns {uri}               returns self for fluent chaining
 */
Uri.prototype.replaceParam = function(key, newVal, oldVal) {
    return this.deleteParam(key, oldVal)
               .addParam(key, newVal);
};

/**
 * Scheme name, colon and doubleslash, as required.
 * @returns {String} http:// or simply //
 */
Uri.prototype.getScheme = function() {
    var s = '';

    if(this.getProtocol()) {
        s += this.getProtocol();
        if(this.getProtocol().indexOf(':') !== this.getProtocol().length - 1) {
            s += ':';
        }
        s += '//';
    } else if(this.getHost()) {
        s += '//';
    }

    return s;
};

/**
 * Same as Mozilla nsIURI.prePath.
 * @see  https://developer.mozilla.org/en/nsIURI
 * @returns {String} scheme://host:port
 */
Uri.prototype.getOrigin = function() {
    var s = this.getScheme();

    if(this.getHost()) {
        s += this.getHost();
        if(this.getPort()) {
            s += ':' + this.getPort();
        }
    }

    return s;
};

/**
 * Returns url root.
 * @returns {String} scheme://host:port + path without last
 */
Uri.prototype.getRoot = function() {
    var s = this.getOrigin();

    if(this.getPath()) {
        s += this.getPath().replace(/\/[^\/]*$/, '');
    }

    return s;
};

/**
 * Returns an array of path parts.
 * @returns {Object} path parts
 */
Uri.prototype.getPathParts = function() {
    return this.getPath().split('/');
};

/**
 * Serializes the internal state of the Uri object.
 * @returns {String}
 */
Uri.prototype.toString = function() {
    var s = this.getOrigin();

    if(this.getPath()) {
        if(this.getPath().indexOf('/') !== 0 && s[s.length - 1] !== '/') {
            s += '/' + this.getPath();
        } else {
            s += this.getPath();
        }
    } else {
        if(this.getHost() && (this.getQuery().toString() || this.getAnchor())) {
            s += '/';
        }
    }
    if(this.getQuery().toString()) {
        if(this.getQuery().toString().indexOf('?') !== 0) {
            s += '?';
        }
        s += this.getQuery().toString();
    }

    if(this.getAnchor()) {
        if(this.getAnchor().indexOf('#') !== 0) {
            s += '#';
        }
        s += this.getAnchor();
    }

    return s;
};

/**
 * Serializes the internal state of the Uri object
 * and replaces empty parts from current page state.
 * @returns {String}
 */
Uri.prototype.build = function() {
    var s = '';

    // No protocol/host – set current
    s += this.getProtocol() ? this.getProtocol() : window.location.protocol;
    s += (s.indexOf(':') !== s.length - 1) ? '://' : '//';

    s += this.getHost() ? this.getHost() : window.location.hostname;

    if(this.getPort()) {
        s += ':' + this.getPort();
    } else if(!this.getHost() && window.location.hostname) {
        s += ':' + window.location.port;
    }

    if(this.getPath()) {
        s += this.getPath();
    } else if(!this.getHost()) {
        s += window.location.pathname;
    } else {
        s += '/';
    }

    if(this.getQuery()) {
        if(this.getQuery().indexOf('?') !== 0) {
            s += '?';
        }
        s += this.getQuery();
    }

    if(this.getAnchor()) {
        if(this.getAnchor().indexOf('#') !== 0) {
            s += '#';
        }
        s += this.getAnchor();
    }

    return s;
};

provide(Uri);

});

/* ../../libs/bem-history/common.blocks/uri/uri.js end */
;
/* ../../libs/bem-core/common.blocks/querystring/__uri/querystring__uri.vanilla.js begin */
/**
 * @module querystring__uri
 * @description A set of helpers to work with URI
 */

modules.define('querystring__uri',  function(provide) {

// Equivalency table for cp1251 and utf8.
var map = { '%D0' : '%D0%A0', '%C0' : '%D0%90', '%C1' : '%D0%91', '%C2' : '%D0%92', '%C3' : '%D0%93', '%C4' : '%D0%94', '%C5' : '%D0%95', '%A8' : '%D0%81', '%C6' : '%D0%96', '%C7' : '%D0%97', '%C8' : '%D0%98', '%C9' : '%D0%99', '%CA' : '%D0%9A', '%CB' : '%D0%9B', '%CC' : '%D0%9C', '%CD' : '%D0%9D', '%CE' : '%D0%9E', '%CF' : '%D0%9F', '%D1' : '%D0%A1', '%D2' : '%D0%A2', '%D3' : '%D0%A3', '%D4' : '%D0%A4', '%D5' : '%D0%A5', '%D6' : '%D0%A6', '%D7' : '%D0%A7', '%D8' : '%D0%A8', '%D9' : '%D0%A9', '%DA' : '%D0%AA', '%DB' : '%D0%AB', '%DC' : '%D0%AC', '%DD' : '%D0%AD', '%DE' : '%D0%AE', '%DF' : '%D0%AF', '%E0' : '%D0%B0', '%E1' : '%D0%B1', '%E2' : '%D0%B2', '%E3' : '%D0%B3', '%E4' : '%D0%B4', '%E5' : '%D0%B5', '%B8' : '%D1%91', '%E6' : '%D0%B6', '%E7' : '%D0%B7', '%E8' : '%D0%B8', '%E9' : '%D0%B9', '%EA' : '%D0%BA', '%EB' : '%D0%BB', '%EC' : '%D0%BC', '%ED' : '%D0%BD', '%EE' : '%D0%BE', '%EF' : '%D0%BF', '%F0' : '%D1%80', '%F1' : '%D1%81', '%F2' : '%D1%82', '%F3' : '%D1%83', '%F4' : '%D1%84', '%F5' : '%D1%85', '%F6' : '%D1%86', '%F7' : '%D1%87', '%F8' : '%D1%88', '%F9' : '%D1%89', '%FA' : '%D1%8A', '%FB' : '%D1%8B', '%FC' : '%D1%8C', '%FD' : '%D1%8D', '%FE' : '%D1%8E', '%FF' : '%D1%8F' };

function convert(str) {
    // Symbol code in cp1251 (hex) : symbol code in utf8)
    return str.replace(
        /%.{2}/g,
        function($0) {
            return map[$0] || $0;
        });
}

function decode(fn,  str) {
    var decoded = '';
    
    // Try/catch block for getting the encoding of the source string.
    // Error is thrown if a non-UTF8 string is input.
    // If the string was not decoded, it is returned without changes.
    try {
        decoded = fn(str);
    } catch (e1) {
        try {
            decoded = fn(convert(str));
        } catch (e2) {
            decoded = str;
        }
    }
    
    return decoded;
}

provide(/** @exports */{
    /**
     * Decodes URI string
     * @param {String} str
     * @returns {String}
     */
    decodeURI : function(str) {
        return decode(decodeURI,  str);
    },

    /**
     * Decodes URI component string
     * @param {String} str
     * @returns {String}
     */
    decodeURIComponent : function(str) {
        return decode(decodeURIComponent,  str);
    }
});

});

/* ../../libs/bem-core/common.blocks/querystring/__uri/querystring__uri.vanilla.js end */
;
/* ../../libs/bem-history/common.blocks/history/_provider/history_provider_history-api.js begin */
/**
 * Modificator for BEM-block history which provides native history API support.
 */
modules.define('history', ['inherit', 'jquery', 'uri'], function(provide, inherit, $, Uri, Base) {

if(!Base.hasNativeAPI()) {
    provide(Base);
    return;
}

provide(inherit(Base, {

    /**
     * Reaction for the window popstate event.
     * @private
     */
    _onPopState : function(e) {
        var state = e.originalEvent.state;

        // Ignore initial popstate
        if(state === null) {
            return;
        }

        this.state = this._normalizeState(state, document.title, window.location.href);

        // Remove silent param to fix back-forward buttons work
        // after location silent=true flag usage
        this.state.data && delete this.state.data.silent;

        this.emit('statechange', { state : state, nativeApi : true });
    },

    _bindEvents : function() {
        $(window).on('popstate', $.proxy(this._onPopState, this));

        return this;
    },

    _resetUrl : function() {
        var uri = Uri.parse(window.location.href);

        if(uri.getAnchor()) {
            window.history.replaceState(null, document.title, this._removeHashbang(window.location.href));
        }
        return this;
    },

    _syncState : function() {
        // Replace null with undefined to catch initial popstate
        if(window.history.state === null) {
            window.history.replaceState(undefined, document.title, window.location.href);
        }
        if(!this.state) {
            this.state = this._normalizeState(undefined, document.title, window.location.href);
        }

        return this;
    },

    changeState : function(method, state) {
        window.history[method + 'State'](state, state.title || document.title, state.url);
        this.state = state;

        return this.emit('statechange', { state : state, nativeApi : true });
    }

}));

});

/* ../../libs/bem-history/common.blocks/history/_provider/history_provider_history-api.js end */
;
/* ../../libs/bem-history/common.blocks/history/_provider/history_provider_hashchange.js begin */
/**
 * Modificator for BEM-block history which provides history API support
 * through hashchange fallback.
 */
modules.define('history', ['inherit', 'jquery', 'uri'], function(provide, inherit, $, Uri, Base) {

if(!('onhashchange' in window) || Base.hasNativeAPI()) {
    provide(Base);
    return;
}

provide(inherit(Base, {
    /**
     * @constructor
     */
    _onHashChange : function() {
        this.state = this._normalizeState(undefined, document.title, this._removeHashbang(window.location.href));

        this.emit('statechange', { state : this.state, nativeApi : false });
    },

    _bindEvents : function() {
        $(window).on('hashchange', $.proxy(this._onHashChange, this));

        return this;
    },

    _syncState : function() {
        this.state = this._normalizeState(undefined, document.title, this._removeHashbang(window.location.href));
        return this;
    },

    /**
     * Generates hashbang from url.
     * ../search?p=1 => ..#!/search?p=1.
     *
     * @param {String} url
     * @returns {String}
     * @private
     */
    _generateHashbang : function(url) {
        var uri = Uri.parse(url),
            path = uri.getPathParts();

        return '!/' + path[path.length - 1] + uri.getQuery();
    },

    /**
     * Do not reset url after the history initialization.
     * Hashbang will be added during the first changeState.
     */
    _resetUrl : function() {
        return this;
    },

    changeState : function(method, state) {
        var uri = Uri.parse(state.url);

        if((uri.getHost() && uri.getHost() !== window.location.hostname) ||
            (uri.getPort() && uri.getPort() !== window.location.port) ||
            (uri.getProtocol() && uri.getProtocol() !== window.location.protocol.replace(':', ''))) {

            throw new Error('SECURITY_ERR: DOM Exception 18');
        } else {
            this.state = state;
            window.location.hash = this._generateHashbang(state.url);
        }
    }

}));

});

/* ../../libs/bem-history/common.blocks/history/_provider/history_provider_hashchange.js end */
;
/* ../../common.blocks/dict/dict.js begin */
modules.define('dict', [], function(provide) {
    
    var dict = {
            "abandon": ["[ə'bændən]", "покидать, оставлять"],
            "abate": ["[ə'beit]", "уменьшать, ослаблять"],
            "abbreviation": ["[ə,bri:vi'ei∫(ə)n]", "сокращение, урезание"],
            "abduct": ["[əb'd∧kt]", "похищать, насильно уводить"],
            "abhor": ["[əb'ho:]", "питать отвращение"],
            "abolish": ["[ə'bоli∫]", "аннулировать, отменять"],
            "abominate": ["[ə'bоmineit]", "питать отвращение, ненавидеть"],
            "abort": ["[ə'bo:t]", "аварийное прекращение"],
            "abrupt": ["[ə'br∧pt]", "внезапный"],
            "absolve": ["[əb'zоlv]", "освобождать, избавлять"],
            "abstain": ["[əb'stein]", "воздерживаться"],
            "abstruse": ["[æb'stru:s]", "глубокомысленный, серьезный"],
            "absurd": ["[əb'sə:d]", "нелепый, абсурдный"],
            "abyss": ["[ə'bis]", "бездна, пропасть"],
            "accessible": ["[ək'sesəbl]", "доступный"],
            "acclaim": ["[ə'kleim]", "шумное приветствие"],
            "accomplice": ["[ə'kоmplis]", "сообщник, соучастник"],
            "accuse": ["[ə'kju:z]", "винить, обвинять"],
            "acquiesce": ["[,ækwi'es]", "уступать, молча соглашаться"],
            "acrid": ["['ækrid]", "острый, резкий"],
            "actuate": ["['ækʧueit]", "приводить в действие"],
            "adapt": ["[ə'dæpt]", "приспосабливать"],
            "adept": ["['ædept]", "знаток, эксперт"],
            "adequate": ["['ædikwət]", "адекватный, соответствующий"],
            "adhere": ["[əd'hiə]", "прилипать, приставать"],
            "adjourn": ["[ə'ʤə:n]", "откладывать, отсрочивать"],
            "admonish": ["[əd'mоni∫]", "предостерегать"],
            "adorn": ["[ə'do:n]", "украшать"],
            "advent": ["['ædvənt]", "наступление, прибытие"],
            "advocate": ["['ædvəkət]", "защитник"],
            "affable": ["['æfəbl]", "приветливый"],
            "affect": ["['æfekt]", "оказывать воздействие"],
            "affiliate": ["[ə'filieit]", "филиал, отделение"],
            "affinity": ["[ə'finəti]", "близость, родство"],
            "affliction": ["[ə'flik∫(ə)n]", "страдание, печаль"],
            "aggravate": ["['ægrəveit]", "отягчать, усугублять"],
            "agile": ["['æʤail]", "проворный"],
            "agitate": ["['æʤiteit]", "агитировать"],
            "ailment": ["['eilmənt]", "нездоровье"],
            "akin": ["[ə'kin]", "родственный, близкий"],
            "allegiance": ["[ə'li:ʤ(ə)n(t)s]", "лояльность, верность"],
            "alleviate": ["[ə'li:vieit]", "облегчать"],
            "allocate": ["['æləkeit]", "назначать"],
            "allot": ["[ə'lоt]", "предоставлять, выделять"],
            "aloft": ["[ə'lоft]", "наверху"],
            "aloof": ["[ə'lu:f]", "сторонящийся"],
            "amateurish": ["['æmət(ə)ri∫]", "дилетантский, любительский"],
            "amazing": ["[ə'meiziɳ]", "изумительный, ошеломительный"],
            "ambient": ["['æmbiənt]", "окружающий, внешний"],
            "ambiguous": ["[æm'bigjuəs]", "двусмысленный"],
            "ambivalence": ["[æm'biv(ə)lən(t)s]", "двойственный подход"],
            "ambivalent": ["[æm'biv(ə)lənt]", "двойственный, противоречивый"],
            "amelioration": ["[ə,mi:li(ə)'rei∫(ə)n]", "мелиорация"],
            "amenable": ["[ə'mi:nəbl]", "ответственный"],
            "amicable": ["['æmikəbl]", "дружелюбный, дружеский"],
            "amnesty": ["['æmnəsti]", "амнистия, помилование"],
            "analogous": ["[ə'næləgəs]", "аналогичный"],
            "anecdote": ["['ænikdəut]", "эпизод, случай"],
            "annex": ["['æneks]", "приложение, дополнение"],
            "anonymous": ["[ə'nоniməs]", "анонимный, безымянный"],
            "antagonism": ["[æn'tægəniz(ə)m]", "вражда"],
            "antagonist": ["[æn'tægənist]", "антагонист"],
            "anxious": ["['æɳ(k)∫əs]", "озабоченный, беспокоящийся"],
            "apathy": ["['æpəθi]", "апатия, безразличие"],
            "Apollonian": ["[,æpə'ləuniən]", "подобный Аполлону"],
            "appealing": ["[ə'pi:liɳ]", "трогательный, умоляющий"],
            "appease": ["[ə'pi:z]", "успокаивать"],
            "applaud": ["[ə'plo:d]", "аплодировать, хлопать"],
            "appraise": ["[ə'preiz]", "оценивать, расценивать"],
            "approbation": ["[,æprə(u)'bei∫(ə)n]", "одобрение, похвала"],
            "apt": ["[æpt]", "подходящий, соответствующий"],
            "aqueous": ["['eikwiəs]", "водный, водяной"],
            "arduous": ["['a:djuəs]", "трудный, тяжёлый"],
            "armistice": ["['a:mistis]", "прекращение военных действий"],
            "aroma": ["[ə'rəumə]", "аромат, приятный запах"],
            "arrogant": ["['ærəgənt]", "заносчивый, высокомерный"],
            "articulate": ["[a:'tikjələt]", "чёткий, членораздельный"],
            "ascertain": ["[,æsə'tein]", "выяснять, устанавливать"],
            "assail": ["[ə'seil]", "нападать, атаковать"],
            "assault": ["[ə'so:lt]", "атаковать, штурмовать"],
            "assert": ["[ə'sə:t]", "утверждать"],
            "assiduous": ["[ə'sidjuəs]", "усердный, прилежный"],
            "astonishing": ["[ə'stоni∫iɳ]", "изумительный, ошеломительный"],
            "astute": ["[ə'stju:t]", "хитроумный, хитрый"],
            "atone": ["[ə'təun]", "заглаживать, искупать"],
            "atrocious": ["[ə'trəu∫əs]", "свирепый, жестокий"],
            "audacious": ["[o:'dei∫əs]", "бесстрашный, отважный"],
            "augment": ["['o:gmənt]", "аугмент, приращение"],
            "august": ["[o:'g∧st]", "августейший"],
            "austere": ["[o:'stiə]", "строгий"],
            "authorize": ["['o:θ(ə)raiz]", "уполномочивать"],
            "autocracy": ["[o:'tоkrəsi]", "автократия, абсолютизм"],
            "automaton": ["[o:'tоmət(ə)n]", "автомат"],
            "autonomy": ["[o:'tоnəmi]", "независимость"],
            "avalanche": ["['æv(ə)la:n(t)∫]", "лавина, обвал"],
            "avarice": ["['ævəris]", "алчность"],
            "aversion": ["[ə'və:∫(ə)n]", "отвращение, антипатия"],
            "avert": ["[ə'və:t]", "отворачиваться"],
            "aviator": ["['eivieitə]", "авиатор, лётчик"],
            "avid": ["['ævid]", "жадный, скупой"],
            "avoid": ["[ə'vоid]", "избегать, остерегаться"],
            "avouch": ["[ə'vauʧ]", "заявлять, утверждать"],
            "bacchanalian": ["[,bækə'neiliən]", "пьяница, гуляка"],
            "balmy": ["['ba:mi]", "ароматный, благоухающий"],
            "ban": ["[bæn]", "запрещение"],
            "bankrupt": ["['bæɳkr∧pt]", "несостоятельный должник"],
            "bashful": ["['bæ∫fəl]", "застенчивый, робкий"],
            "bead": ["[bi:d]", "шарик, бусина"],
            "beckon": ["['bek(ə)n]", "подзывать кивком головы"],
            "becoming": ["[bi'k∧miɳ]", "подобающий, приличествующий"],
            "befall": ["[bi'fo:l]", "приключаться, происходить"],
            "belligerence": ["[be'liʤərən(t)s]", "воинственность"],
            "belligerent": ["[bi'liʤər(ə)nt]", "воюющая сторона"],
            "benevolent": ["[bi'nevələnt]", "благожелательный, благосклонный"],
            "bequeath": ["[bi'kwi:∂]", "завещать"],
            "besiege": ["[bi'si:ʤ]", "осаждать"],
            "bestow": ["[bi'stəu]", "давать, даровать"],
            "betray": ["[bi'trei]", "изменять, предавать"],
            "beverage": ["['bevəriʤ]", "напиток"],
            "bias": ["['baiəs]", "наклон, покатость"],
            "bicker": ["['bikə]", "перебранка"],
            "biography": ["[bai'оgrəfi]", "биография"],
            "bland": ["[blænd]", "вежливый"],
            "blend": ["[blend]", "смешивать"],
            "blizzard": ["['blizəd]", "снежная буря, буран"],
            "bloom": ["[blu:m]", "цвет, цветение"],
            "bolster": ["['bəulstə]", "валик под подушкой"],
            "bothersome": ["['bо∂əs(ə)m]", "надоедливый, докучливый"],
            "bough": ["[bau]", "сук"],
            "breakthrough": ["['breikθru:]", "проникновение внутрь"],
            "breeze block": ["['bri:zblоk]", "шлакобетонный блок"],
            "brilliant": ["['briliənt]", "бриллиант"],
            "brittle": ["['britl]", "ломкий, хрупкий"],
            "brochure": ["['brəu∫uə]", "брошюра, буклет"],
            "brutal": ["['bru:tl]", "бесчеловечный, жестокий"],
            "bulky": ["['b∧lki]", "большой, объёмистый"],
            "cajole": ["[kə'ʤəul]", "умасливать, упрашивать"],
            "calm": ["[ka:m]", "спокойный, мирный"],
            "camouflage": ["['kæməfla:Ʒ]", "камуфляж, маскировка"],
            "canvass": ["['kænvəs]", "обсуждать"],
            "capable": ["['keipəbl]", "способный на что-л."],
            "captivate": ["['kæptiveit]", "очаровывать, пленять"],
            "carefree": ["['kɛəfri:]", "беззаботный, беспечный"],
            "caricature": ["[,kærikə'tjuə]", "карикатура"],
            "carnage": ["['ka:niʤ]", "резня, кровавая бойня"],
            "cataclysm": ["['kætəkliz(ə)m]", "катаклизм"],
            "catastrophe": ["[kə'tæstrəfi]", "катастрофа, трагедия"],
            "cautious": ["['ko:∫əs]", "осторожный, осмотрительный"],
            "celebrated": ["['seləbreitid]", "знаменитый"],
            "censure": ["['sen(t)∫ə]", "неодобрение, осуждение"],
            "centennial": ["[sen'teniəl]", "вековой, столетний"],
            "chaffer": ["['ʧæfə]", "спор, торг"],
            "chasm": ["['kæz(ə)m]", "глубокая трещина, расщелина"],
            "cherish": ["['ʧeri∫]", "заботливо относиться, ухаживать"],
            "chicanery": ["[∫i'kein(ə)ri]", "крючкотворство"],
            "chide": ["[ʧaid]", "распекать, ругать"],
            "chilly": ["['ʧili]", "холодный"],
            "chubby": ["['ʧ∧bi]", "круглолицый, полнощёкий"],
            "cicerone": ["[,ʧiʧə'rəuni]", "чичероне, гид"],
            "cite": ["[sait]", "ссылаться"],
            "clash": ["[klæ∫]", "сталкиваться"],
            "classify": ["['klæsifai]", "классифицировать, систематизировать"],
            "cliché": ["['kli:∫ei]", "клише"],
            "clumsy": ["['kl∧mzi]", "неповоротливый, неуклюжий"],
            "coalescence": ["[kəuə'les(ə)n(t)s]", "сращивание, срастание"],
            "coax": ["[kəuks]", "убеждать, упрашивать"],
            "coin box": ["['kоinbоks]", "монетоприёмник"],
            "collaborate": ["[kə'læb(ə)reit]", "работать совместно, сотрудничать"],
            "colossal": ["[kə'lоs(ə)l]", "большой, грандиозный"],
            "commence": ["[kə'men(t)s]", "начинать"],
            "commerce": ["['kоmə:s, kəmə:s]", "торговля"],
            "compact": ["[kəm'pækt]", "компактный"],
            "compel": ["[kəm'pel]", "заставлять, вынуждать"],
            "compliment": ["['kоmplimənt]", "любезность, комплимент"],
            "comprehensible": ["[,kоmpri'hen(t)səbl]", "понятный, постижимый"],
            "comprise": ["[kəm'praiz]", "включать"],
            "concede": ["[kən'si:d]", "уступать"],
            "concise": ["[kən'sais]", "краткий"],
            "concoct": ["[kən'kоkt]", "состряпать"],
            "concord": ["['kоɳko:d]", "согласованность"],
            "concurrent": ["[kən'k∧r(ə)nt]", "сопутствующее обстоятельство"],
            "condemn": ["[kən'dem]", "осуждать, порицать"],
            "condone": ["[kən'dəun]", "мириться с чем-л."],
            "conducive": ["[kən'dju:siv]", "благоприятный, подходящий"],
            "configuration": ["[kən,figju'rei∫(ə)n]", "конфигурация"],
            "confiscate": ["['kоnfiskeit]", "конфисковать"],
            "conform": ["[kən'fo:m]", "согласовывать, сообразовывать"],
            "congregate": ["['kоɳgrigeit]", "собирать"],
            "consequential": ["[,kоn(t)si'kwen(t)∫(ə)l]", "косвенный, побочный"],
            "consistent": ["[kən'sist(ə)nt]", "последовательный, стойкий"],
            "conspicuous": ["[kən'spikjuəs]", "видный, заметный"],
            "construe": ["[kən'stru:]", "толковать, объяснять"],
            "contaminate": ["[kən'tæmineit]", "загрязнять"],
            "contemplate": ["['kоntəmpleit]", "обозревать, созерцать"],
            "contention": ["[kən'ten(t)∫(ə)n]", "спор"],
            "contrive": ["[kən'traiv]", "придумывать, изобретать"],
            "controversial": ["[,kоntrə'və:∫(ə)l]", "спорный, сомнительный"],
            "controversy": ["['kоntrəvə:si]", "дебаты, дискуссия"],
            "convey": ["[kən'vei]", "перевозить, переправлять"],
            "conviction": ["[kən'vik∫(ə)n]", "осуждение, признание виновным"],
            "conviviality": ["[kən,vivi'æləti]", "весёлость"],
            "copious": ["['kəupiəs]", "обильный"],
            "corporeal": ["[ko:'po:riəl]", "телесный"],
            "corpulent": ["['ko:pjulənt]", "дородный, жирный"],
            "courteous": ["['kə:tiəs]", "вежливый, обходительный"],
            "covert": ["['k∧vət]", "убежище, прибежище"],
            "cozy up": ["[,kəuzi'∧p]", "делать уютнее"],
            "crave": ["[kreiv]", "страстно желать, жаждать"],
            "crouch": ["[krauʧ]", "припадать к земле"],
            "cumbersome": ["['k∧mbəsəm]", "громоздкий, объёмный"],
            "curious": ["['kjuəriəs]", "любопытный"],
            "curtail": ["[kə:'teil]", "сокращать, укорачивать"],
            "daring": ["['dɛəriɳ]", "смелость"],
            "daunt": ["[do:nt]", "обуздывать, укрощать"],
            "dazzle": ["['dæzl]", "ослепление"],
            "decadent": ["['dekəd(ə)nt]", "декадент"],
            "decipher": ["[di'saifə]", "декодировать, раскодировать"],
            "declivity": ["[di'kliviti]", "склон"],
            "decorate": ["['dek(ə)reit]", "украшать, убирать"],
            "decorous": ["['dek(ə)rəs]", "благопристойный, порядочный"],
            "decrement": ["['dekrimənt]", "понижение, уменьшение"],
            "deduction": ["[di'd∧k∫(ə)n]", "вычет"],
            "defame": ["[di'feim]", "поносить, клеветать"],
            "defect": ["[di'fekt]", "недостаток, дефект"],
            "defiant": ["[di'faiənt]", "вызывающий"],
            "deficient": ["[di'fi∫(ə)nt]", "недостающий, отсутствующий"],
            "definitive": ["[di'finitiv]", "окончательный"],
            "degenerate": ["[di'ʤen(ə)rit]", "выродок, дегенерат"],
            "dehydrate": ["[,di:hai'dreit]", "обезвоживать"],
            "deity": ["['di:iti]", "божество, бог"],
            "dejected": ["[di'ʤektid]", "грустный, печальный"],
            "delightful": ["[di'laitfəl]", "восхитительный, очаровательный"],
            "deluge": ["['delju:ʤ]", "потоп, наводнение"],
            "demolish": ["[di'mоli∫]", "разрушать, уничтожать"],
            "denote": ["[di'nəut]", "отмечать, обозначать"],
            "depress": ["[di'pres]", "подчинять, покорять"],
            "deprive": ["[di'praiv]", "отбирать, отнимать"],
            "derelict": ["['derəlikt]", "покинутый, брошенный"],
            "descry": ["[di'skrai]", "рассмотреть, разглядеть"],
            "desecrate": ["['desikreit]", "оскорблять, осквернять"],
            "desiccate": ["['desikeit]", "высушивать, сушить"],
            "desolate": ["['des(ə)lət]", "одинокий, оставленный всеми"],
            "detect": ["[di'tekt]", "замечать, открывать"],
            "deteriorate": ["[di'tiəriəreit]", "ухудшать"],
            "detract": ["[di'trækt]", "отнимать"],
            "detrimental": ["[,detri'ment(ə)l]", "причиняющий ущерб"],
            "devise": ["[di'vaiz]", "разрабатывать, продумывать"],
            "dexterous": ["['dekst(ə)rəs]", "ловкий, проворный"],
            "diligence": ["['diliʤ(ə)n(t)s]", "прилежание, старание"],
            "diligent": ["['diliʤ(ə)nt]", "прилежный, старательный"],
            "dilute": ["[dai'lu:t]", "разжижать, разбавлять"],
            "dimension": ["[dai'men(t)∫(ə)n]", "измерение"],
            "dingy": ["['dinʤi]", "выцветший, тусклый"],
            "dip net": ["['dipnet]", "подсак"],
            "directory": ["[di'rekt(ə)ri]", "руководство, инструкция"],
            "discard": ["['diska:d]", "сбрасывание карт"],
            "discern": ["[di'sə:n]", "разглядеть"],
            "discipline": ["['disəplin]", "дисциплина"],
            "disclose": ["[dis'kləuz]", "выявлять, обнаруживать"],
            "discrepancy": ["[dis'krep(ə)n(t)si]", "разница"],
            "dismal": ["['dizməl]", "мрачный"],
            "dismay": ["[dis'mei]", "испуг, беспокойство"],
            "dismissive": ["[dis'misiv]", "освобождающий"],
            "disparity": ["[dis'pærəti]", "неравенство"],
            "disperse": ["[di'spə:s]", "рассеивать, развеивать"],
            "disprove": ["[dis'pru:v]", "опровергать"],
            "dispute": ["[dis'pju:t]", "диспут, дискуссия"],
            "disseminate": ["[di'semineit]", "рассеивать, разбрасывать"],
            "dissolve": ["[di'zоlv]", "растворять, таять"],
            "divulge": ["[dai'v∧lʤ]", "разглашать, раскрывать"],
            "docile": ["['dəusail]", "восприимчивый, понятливый"],
            "dogged": ["['dоgid]", "упрямый, упорный"],
            "doleful": ["['dəulf(ə)l]", "скорбный, печальный"],
            "dominate": ["['dоmineit]", "управлять, контролировать"],
            "donate": ["[dəu'neit]", "дарить, жаловать"],
            "drastic": ["['dræstik]", "сильнодействующий"],
            "drawback": ["['dro:bæk]", "препятствие"],
            "Aryan": ["['ɛəriən]", "арийский"],
            "drench": ["[drenʧ]", "промокать насквозь"],
            "drought": ["[draut]", "засуха"],
            "drowsy": ["['drauzi]", "засыпающий, дремлющий"],
            "dumbfound": ["[d∧m'faund]", "ошарашить, ошеломить"],
            "dungeon": ["['d∧nʤ(ə)n]", "главная башня"],
            "durable": ["['djuərəbl]", "надёжный, прочный"],
            "dwelling house": ["['dweliɳhaus]", "жилой дом"],
            "dwindle": ["['dwindl]", "сокращаться, уменьшаться"],
            "ecology": ["[i:'kоləʤi]", "экология"],
            "ecumenic(al)": ["[,i:kju'menik((ə)l)]", "всемирный"],
            "eerie": ["['iəri]", "жуткий, зловещий"],
            "elaborate": ["[i'læb(ə)rit]", "тщательно, детально разработанный"],
            "elderly": ["['eld(ə)li]", "пожилой, почтенный"],
            "elegant": ["['eligənt]", "изысканный, элегантный"],
            "elicit": ["[i'lisit]", "извлекать"],
            "emanate": ["['eməneit]", "исходить, истекать"],
            "emancipate": ["[i'mæn(t)sipeit]", "освобождать"],
            "embed": ["[im'bed]", "вставлять, врезать"],
            "embitter": ["[im'bitə]", "озлоблять, раздражать"],
            "emblem": ["['embləm]", "символ, символическое изображение"],
            "eminent": ["['eminənt]", "высокий, вздымающийся"],
            "emit": ["[i'mit]", "испускать, выделять"],
            "emulate": ["['emjuleit]", "стремиться превзойти"],
            "enchanting": ["[en'ʧa:ntiɳ]", "очаровательный, обаятельный"],
            "encomium": ["[in'kəumiəm]", "восхваление, панегирик"],
            "engender": ["[in'ʤendə]", "возбуждать, вызывать"],
            "enhance": ["[in'ha:n(t)s]", "увеличивать, усиливать"],
            "enigma": ["[i'nigmə]", "головоломка, загадка"],
            "Y chromosome": ["['wai,krəuməsəum]", "Y-хромосома"],
            "ennui": ["['оnwi:]", "скука, тоска"],
            "ensue": ["[in'sju:]", "получаться в результате"],
            "enumerate": ["[i'nju:m(ə)reit]", "перечислять"],
            "enunciate": ["[i'n∧n(t)sieit]", "ясно, отчётливо произносить"],
            "envelope": ["['envələup]", "конверт"],
            "environ": ["[in'vaiər(ə)n]", "окружать, охватывать"],
            "epiphyte": ["['epifait]", "эпифит"],
            "epitaph": ["['epita:f]", "эпитафия"],
            "epithet": ["['epiθet]", "эпитет"],
            "era": ["['iərə]", "эра"],
            "eradicate": ["[i'rædikeit]", "вырывать с корнем"],
            "eschew": ["[is'ʧu:]", "воздерживаться, избегать"],
            "espouse": ["[is'pauz]", "жениться"],
            "essay": ["['esei]", "испытание, опробование"],
            "esteem": ["[is'ti:m]", "пиетет, почтение"],
            "estrange": ["[is'treinʤ]", "отдалять, отстранять"],
            "eulogy": ["['ju:ləʤi]", "хвалебная речь, панегирик"],
            "evade": ["[i'veid]", "ускользать"],
            "evanescent": ["[,i:və'nes(ə)nt]", "исчезающий, испаряющийся"],
            "even": ["['i:v(ə)n]", "вечер"],
            "exacerbate": ["[ig'zæsəbeit]", "обострять, осложнять"],
            "excavate": ["['ekskəveit]", "копать, рыть"],
            "exceed": ["[ik'si:d]", "превышать"],
            "excerpt": ["['eksə:pt]", "выборка, выдержка"],
            "excrete": ["[eks'kri:t]", "выделять, извергать"],
            "exhaustive": ["[ig'zo:stiv]", "исчерпывающий, всесторонний"],
            "exhortation": ["[,egzo:'tei∫(ə)n]", "призыв, увещевание"],
            "expendable": ["[ik'spendəbl]", "потребляемый, расходуемый"],
            "expire": ["[ik'spaiə]", "закончиться, истечь"],
            "explore": ["[ik'splo:]", "исследовать, рассматривать"],
            "expunge": ["[ik'sp∧nʤ]", "вычёркивать, удалять"],
            "extol": ["[ik'stəul]", "восхвалять, превозносить"],
            "extract": ["[ik'strækt]", "вытаскивать, извлекать"],
            "extravagant": ["[ik,strævəgənt]", "неэкономный, расточительный"],
            "fable": ["['feibl]", "басня"],
            "facilitate": ["[fə'siliteit]", "облегчать"],
            "famine fever": ["[,fæmin'fi:və]", "голодный тиф"],
            "fatigue party": ["[fə'ti:g,pa:ti]", "рабочая команда"],
            "faulty": ["['fo:lti]", "неисправный, повреждённый"],
            "feasible": ["['fi:zəbl]", "реальный, выполнимый"],
            "fee": ["[fi:]", "вознаграждение, гонорар"],
            "feeble": ["['fi:bl]", "немощный, слабосильный"],
            "felicity": ["[fə'lisəti]", "счастье"],
            "ferocious": ["[fə'rəu∫əs]", "дикий"],
            "fickle": ["['fikl]", "непостоянный, переменчивый"],
            "fiery": ["['faiəri]", "огненный, пламенный"],
            "flagrant": ["['fleigrənt]", "ужасающий, ужасный"],
            "flaw": ["[flo:]", "трещина, щель"],
            "flee": ["[fli:]", "убегать, спасаться бегством"],
            "fluctuate": ["['fl∧kʧueit]", "быть неустойчивым, меняться"],
            "foggy": ["['fоgi]", "туманный, в тумане"],
            "forego": ["[fo:'gəu]", "предшествовать, идти впереди"],
            "foremost": ["['fo:məust]", "передний, передовой"],
            "forestall": ["[fo:'sto:l]", "следовать впереди"],
            "formative": ["['fo:mətiv]", "образующий"],
            "fragile": ["['fræʤail]", "ломкий, хрупкий"],
            "fragment": ["['frægmənt]", "обломок"],
            "fragrant": ["['freigrənt]", "ароматный, благоухающий"],
            "frail": ["[freil]", "тростник"],
            "frenetic": ["[frə'netik]", "буйный, бурный"],
            "fugitive": ["['fju:ʤətiv]", "беглец"],
            "fuse box": ["['fju:z,bоks]", "закрытый плавкий предохранитель"],
            "gale": ["[geil]", "шторм"],
            "garrulous": ["['gær(ə)ləs]", "болтливый, говорливый"],
            "gaudy": ["['go:di]", "большое празднество"],
            "genial": ["['ʤi:niəl]", "весёлый, общительный"],
            "germane": ["[ʤə:'mein]", "уместный, подходящий"],
            "ghastly": ["['ga:stli]", "наводящий ужас, жуткий"],
            "glorify": ["['glo:rifai]", "восхвалять, возвеличивать"],
            "gorgeous": ["['go:ʤəs]", "вычурный, эффектный"],
            "grace cup": ["['greisk∧p]", "кубок или чаша"],
            "grasp": ["[gra:sp]", "схватывание"],
            "gratuitous": ["[grə'tju:itəs]", "бесплатный, даровой"],
            "gravid": ["['grævid]", "беременная"],
            "gravitas": ["['grævitæs]", "авторитет, вес"],
            "gravitate": ["['græviteit]", "тяготеть, стремиться"],
            "graze": ["[greiz]", "слегка касаться, задевать"],
            "gregarious": ["[gri'gɛəriəs]", "живущий стаями, стадами"],
            "grip vice": ["['gripvais]", "зажимные тиски"],
            "grumble": ["['gr∧mbl]", "ворчать, жаловаться"],
            "guile": ["[gail]", "обман"],
            "gullible": ["['g∧libl]", "доверчивый, легковерный"],
            "gusto": ["['g∧stəu]", "удовольствие, смак"],
            "haggle": ["['hægl]", "вздорить, пререкаться"],
            "hamper": ["['hæmpə]", "препятствовать, мешать"],
            "handpick": ["['hændpik]", "собирать руками"],
            "handy": ["['hændi]", "доступный"],
            "haphazard": ["[,hæp'hæzəd]", "случай, случайность"],
            "harangue": ["[hə'ræɳ]", "речь"],
            "harass": ["['hærəs]", "беспокоить, волновать"],
            "hardship": ["['ha:d∫ip]", "трудность, трудности"],
            "harm": ["[ha:m]", "вред"],
            "havoc": ["['hævək]", "опустошение"],
            "hedonism": ["['hi:d(ə)niz(ə)m]", "гедонизм"],
            "hedonist": ["['hi:d(ə)nist]", "гедонист"],
            "heighten": ["['hait(ə)n]", "повышать"],
            "herald": ["['herəld]", "герольд"],
            "heretic": ["['herətik]", "еретик"],
            "heyday": ["['heidei]", "зенит, расцвет"],
            "hinder": ["['haində]", "задний"],
            "hoax": ["[həuks]", "обман"],
            "hoist": ["[hоist]", "поднимать"],
            "homogeneous": ["[,hоmə'ʤi:niəs]", "однородный"],
            "homonym": ["['hоmənim]", "омоним"],
            "hospitable": ["[hоs'pitəbl]", "гостеприимный, радушный"],
            "hostage": ["['hоstiʤ]", "заложник"],
            "hostel": ["['hоst(ə)l]", "студенческое общежитие"],
            "hostile": ["['hоstail]", "вражеский, неприятельский"],
            "huge": ["[hju:ʤ]", "большой, гигантский"],
            "humiliate": ["[hju:'milieit]", "унижать, оскорблять"],
            "hypocrite": ["['hipəkrit]", "лицемер, ханжа"],
            "ideal": ["[ai'diəl]", "идеал, образец"],
            "illiterate": ["[i'lit(ə)rət]", "неграмотный"],
            "illusion": ["[i'lu:Ʒ(ə)n, i'lju:Ʒ(ə)n]", "иллюзия, обман чувств"],
            "illustrate": ["['iləstreit]", "иллюстрировать, делать иллюстрации"],
            "imbibe": ["[im'baib]", "пить"],
            "immense": ["[i'men(t)s]", "безмерный, очень большой"],
            "immutable": ["[i'mju:təbl]", "неизменный, непреложный"],
            "impair": ["[im'pɛə]", "ослаблять, снижать"],
            "impecunious": ["[,impi'kju:niəs]", "бедный, бедствующий"],
            "impediment": ["[im'pedimənt]", "физический недостаток"],
            "impel": ["[im'pel]", "приводить в движение"],
            "impending": ["[im'pendiɳ]", "нависающий"],
            "imperceptible": ["[,impə'septəbl]", "незаметный, незначительный"],
            "implement": ["['implimənt]", "инструмент, прибор"],
            "impose": ["[im'pəuz]", "класть, помещать"],
            "improvise": ["['imprəvaiz]", "импровизировать"],
            "Te Deum": ["[,tei'deium]", "Тедеум"],
            "incalculable": ["[in'kælkjuləbl]", "неисчислимый, несчётный"],
            "incense": ["['insen(t)s]", "ладан, фимиам"],
            "incessant": ["[in'ses(ə)nt]", "беспрестанный, непрекращающийся"],
            "incognito": ["[,inkоg'ni:təu]", "инкогнито"],
            "incongruous": ["[in'kоɳgruəs]", "несоответственный, несочетаемый"],
            "inconsonant": ["[in'kоn(t)sənənt]", "несовместимый, несообразный"],
            "increment": ["['iɳkrimənt]", "возрастание, расширение"],
            "indifferent": ["[in'dif(ə)r(ə)nt]", "безразличный, равнодушный"],
            "indigent": ["['indiʤənt]", "лишённый"],
            "indignant": ["[in'dignənt]", "негодующий, возмущённый"],
            "induce": ["[in'dju:s]", "побуждать, склонять"],
            "infinitesimal": ["[,infini'tesim(ə)l]", "бесконечно малая величина"],
            "infringe": ["[in'frinʤ]", "нарушать, преступать"],
            "ingenuous": ["[in'ʤenjuəs]", "открытый, прямой"],
            "ingredient": ["[in'gri:diənt]", "составная часть, компонент"],
            "inhibit": ["[in'hibit]", "задерживать, сдерживать"],
            "inhospitable": ["[,inhоs'pitəbl]", "негостеприимный, недружелюбный"],
            "injurious": ["[in'ʤuəriəs]", "вредный"],
            "innocuous": ["[i'nоkjuəs]", "безвредный"],
            "innovative": ["['inəuveitiv, 'inəveitiv]", "новаторский, передовой"],
            "inopportune": ["[in'оpətju:n]", "неподходящий, несвоевременный"],
            "inordinate": ["[i'no:dinət]", "неумеренный"],
            "inroad": ["['inrəud]", "набег, нашествие"],
            "insatiate": ["[in'sei∫iət, in'sei∫ieit]", "ненасытный"],
            "insolent": ["['ins(ə)lənt]", "высокомерный, кичливый"],
            "insolvent": ["[in'sоlv(ə)nt]", "несостоятельный должник"],
            "insult": ["[in's∧lt]", "оскорблять"],
            "insurrection": ["[,ins(ə)'rek∫(ə)n]", "восстание"],
            "intelligible": ["[in'teliʤəbl]", "вразумительный, понятный"],
            "interminable": ["[in'tə:minəbl]", "бесконечный, беспредельный"],
            "intervene": ["[,intə'vi:n]", "вмешиваться"],
            "intimidate": ["[in'timideit]", "пугать"],
            "intrepid": ["[in'trepid]", "бесстрашный, неустрашимый"],
            "intrigue": ["['intri:g]", "интрига, козни"],
            "invaluable": ["[in'væljuəbl]", "бесценный, неоценимый"],
            "inventory": ["['inv(ə)nt(ə)ri]", "опись, реестр"],
            "invincible": ["[in'vin(t)səbl]", "неодолимый, непобедимый"],
            "inviting": ["[in'vaitiɳ]", "заманчивый, манящий"],
            "irate": ["[ai'reit]", "гневный, разгневанный"],
            "irrevocable": ["[i'revəkəbl]", "неотменяемый, бесповоротный"],
            "irritable": ["['iritəbl]", "несдержанный, раздражительный"],
            "jagged": ["['ʤægid]", "зубчатый, зазубренный"],
            "jeopardy": ["['ʤepədi]", "опасность, риск"],
            "jolt": ["[ʤəult]", "толчок"],
            "judicious": ["[ʤu:'di∫əs]", "благоразумный, здравомыслящий"],
            "juncture": ["['ʤ∧ɳkʧə]", "соединение"],
            "knack": ["[næk]", "умение, сноровка"],
            "lag": ["[læg]", "отставание"],
            "landslide": ["['lændslaid]", "обвал, оползень"],
            "lassitude": ["['læsitju:d]", "усталость, утомление"],
            "laud": ["[lo:d]", "похвала, хвала"],
            "leaflet": ["['li:flət]", "листочек, листик"],
            "leaven": ["['lev(ə)n]", "дрожжи, закваска"],
            "legendary": ["['leʤənd(ə)ri]", "легендарный"],
            "lenient": ["['li:niənt]", "снисходительный"],
            "lessen": ["['les(ə)n]", "уменьшаться, сокращаться"],
            "lethargic(al)": ["[lə'θa:ʤik((ə)l)]", "летаргический"],
            "lewd": ["[lju:d, lu:d]", "похотливый"],
            "licentious": ["[lai'sen∫əs]", "безнравственный, распущенный"],
            "likely": ["['laikli]", "вероятный, возможный"],
            "linger": ["['liɳgə]", "засиживаться, задерживаться"],
            "litigate": ["['litigeit]", "судиться"],
            "loafer": ["['ləufə]", "бездельник, тунеядец"],
            "loathsome": ["['ləu∂səm]", "тошнотворный"],
            "locomotion": ["[,ləukə'məu∫(ə)n]", "передвижение, перемещение"],
            "loophole": ["['lu:phəul]", "амбразура, бойница"],
            "lucrative": ["['lu:krətiv]", "прибыльный, выгодный"],
            "lugubrious": ["[lu:'gu:briəs]", "скорбный, печальный"],
            "lukewarm": ["[,lu:k'wo:m]", "тепловатый"],
            "lullaby": ["['l∧ləbai]", "колыбельная"],
            "lure": ["[l(j)uə]", "соблазн"],
            "lurid": ["['l(j)uərid]", "мертвенно-бледный"],
            "lustrous": ["['l∧strəs]", "блестящий, яркий"],
            "luxurious": ["[l∧g'Ʒuriəs]", "богатый, пышный"],
            "magnify": ["['mægnifai]", "увеличивать"],
            "magnitude": ["['mægnitju:d]", "величина, размеры"],
            "makeshift": ["['meik∫ift]", "временная замена"],
            "malady": ["['mælədi]", "болезнь"],
            "malice": ["['mælis]", "злоба"],
            "mature": ["[mə'ʧuə]", "зрелый, спелый"],
            "maxim": ["['mæksim]", "максима, аксиома"],
            "meddle": ["['medl]", "заниматься, интересоваться чем-л."],
            "meek": ["[mi:k]", "кроткий, мягкий"],
            "menace": ["['menis, 'menəs]", "угроза"],
            "merge": ["[mə:ʤ]", "погружаться"],
            "meritorious": ["[,meri'to:riəs]", "заслуживающий одобрения, награды"],
            "mesmerize": ["['mezm(ə)raiz]", "гипнотизировать"],
            "meticulous": ["[mə'tikjələs]", "мелочный"],
            "mingle": ["['miɳgl]", "смешиваться"],
            "minuscule": ["['minəskju:l]", "минускул"],
            "mirth": ["[mə:θ]", "веселье, радость"],
            "misappropriate": ["[,misə'prəuprieit]", "незаконно присвоить, завладеть"],
            "molest": ["[mə'lest]", "заигрывать"],
            "monotonous": ["[mə'nоt(ə)nəs]", "монотонный"],
            "morale": ["[mə'ra:l]", "моральное состояние"],
            "mournful": ["['mo:nf(ə)l, 'mo:nful]", "унылый, угрюмый"],
            "murky": ["['mə:ki]", "тёмный, мрачный"],
            "mutiny": ["['mju:t(ə)ni]", "мятеж, восстание"],
            "mysterious": ["[mi'stiəriəs]", "таинственный"],
            "mythic(al)": ["['miθik(əl)]", "легендарный, мифический"],
            "naughty": ["['no:ti]", "непослушный, капризный"],
            "neglect": ["[ni'glekt]", "пренебрежение, игнорирование"],
            "negligible": ["['negliʤəbl]", "незначительный"],
            "negotiate": ["[ni'gəu∫ieit, ni'gəusieit]", "вести переговоры, договариваться"],
            "nibble": ["['nibl]", "грызть"],
            "nonchalant": ["['nоn∫(ə)lənt]", "бесстрастный"],
            "notable": ["['nəutəbl]", "примечательный, достопримечательный"],
            "notify": ["['nəutifai]", "извещать, уведомлять"],
            "notorious": ["[nəu'to:riəs]", "пользующийся дурной славой"],
            "novel": ["['nоv(ə)l]", "роман"],
            "novice": ["['nоvis]", "начинающий, новичок"],
            "obese": ["[əu'bi:s]", "тучный, толстый"],
            "oblong": ["['оblоɳ]", "продолговатый"],
            "obscene": ["[əb'si:n]", "непристойный, непотребный"],
            "obsequious": ["[əb'si:kwiəs]", "подобострастный, раболепный"],
            "obstinate": ["['оbstinit]", "упрямый, своевольный"],
            "obtrude": ["[əb'tru:d]", "выдвигать, высовывать"],
            "obvious": ["['оbviəs]", "очевидный, заметный"],
            "omen": ["['əumən]", "знак, знамение"],
            "ominous": ["['оminəs]", "предсказывающий, предвещающий"],
            "opportune": ["['оpətju:n]", "благоприятный"],
            "opulent": ["['оpjulənt]", "богатый, состоятельный"],
            "orbit": ["['o:bit]", "орбита"],
            "ordeal": ["[o:'di:l]", "суровое испытание"],
            "ornamental": ["[,o:nə'ment(ə)l]", "декоративный, служащий украшением"],
            "orotund": ["['оrət∧nd]", "звучный, полновесный"],
            "ostracize": ["['оstrəsaiz]", "подвергать остракизму"],
            "outlet": ["['autlet]", "выход, проход"],
            "outrage": ["['autreiʤ]", "грубое нарушение"],
            "outskirt": ["[,aut'skə:t]", "граничить, прилегать"],
            "outspread": ["[,aut'spred]", "распростёртый"],
            "outworn": ["[,aut'wo:n]", "изношенный, поношенный"],
            "overcast": ["['əuvəka:st]", "затянутый облаками"],
            "overcome": ["[,əuvə'k∧m]", "побороть, победить"],
            "overdue": ["[,əuvə'dju:]", "опаздывающий"],
            "override": ["[,əuvə'raid]", "отменять, аннулировать"],
            "overrun": ["[,əuvə'r∧n]", "переходить пределы, границы"],
            "oversight": ["['əuvəsait]", "недосмотр, оплошность"],
            "overstate": ["[,əuvə'steit]", "преувеличивать"],
            "overt": ["['əuvə:t]", "неприкрытый, очевидный"],
            "overtake": ["[,əuvə'teik]", "догнать, наверстать"],
            "overwhelm": ["[,əuvə'welm]", "ошеломлять, поражать"],
            "pacesetter": ["['peissetə]", "лидер"],
            "pacifist": ["['pæsifist]", "пацифист"],
            "pact": ["[pækt]", "договор, конвенция"],
            "panacea": ["[,pænə'si:ə]", "панацея, универсальное средство"],
            "paramour": ["['pærəmuə]", "любовь"],
            "particle": ["['pa:tikl]", "частица"],
            "patronage": ["['pætr(ə)niʤ]", "покровительство, попечительство"],
            "perceive": ["[pə'si:v]", "воспринимать, понимать"],
            "perceptible": ["[pə'septəbl]", "заметный, ощутимый"],
            "perch": ["[pə:ʧ]", "насест, жёрдочка"],
            "peril": ["['per(ə)l]", "опасность"],
            "perilous": ["['per(ə)ləs, 'periləs]", "опасный, рискованный"],
            "permeate": ["['pə:mieit]", "проникать, проходить сквозь"],
            "perplexing": ["[pə'pleksiɳ]", "трудный"],
            "perspicuous": ["[pə'spikjuəs]", "понятный, чёткий"],
            "pervade": ["[pə'veid]", "заполнять, наполнять"],
            "phenomenal": ["[fi'nоmin(ə)l]", "феноменальный, выдающийся"],
            "pierce": ["[piəs]", "прокалывать, протыкать"],
            "pillage": ["['piliʤ]", "грабёж, мародёрство"],
            "placate": ["[plə'keit]", "умиротворять"],
            "plethora": ["['pleθ(ə)rə]", "полнокровие"],
            "plush": ["[pl∧∫]", "плюш"],
            "poky": ["['pəuki]", "тесный, убогий"],
            "portion": ["['po:∫(ə)n]", "доза, порция"],
            "portray": ["[po:'trei]", "рисовать портрет"],
            "posthumous": ["['pоstjəməs]", "посмертный"],
            "postpone": ["[,pəust'pəun]", "откладывать"],
            "pounce": ["[paun(t)s]", "коготь"],
            "precarious": ["[pri'kɛəriəs]", "ненадёжный, сомнительный"],
            "precept": ["['pri:sept]", "правило поведения, принцип"],
            "precise": ["[pri'sais]", "точный"],
            "preface": ["['prefəs]", "предисловие"],
            "premier": ["['premiə]", "премьер, премьер-министр"],
            "presage": ["['presiʤ]", "знамение, предзнаменование"],
            "prescribe": ["[pri'skraib]", "предписывать"],
            "pressing": ["['presiɳ]", "тягостный, обременительный"],
            "presumptuous": ["[pri'z∧mpʧuəs, pri'z∧mptjuəs]", "самонадеянный"],
            "pretence": ["[pri'ten(t)s]", "притворство"],
            "pretext": ["['pri:tekst]", "отговорка, повод"],
            "prevail": ["[pri'veil]", "восторжествовать, одержать победу"],
            "prevalent": ["['prev(ə)lənt]", "распространённый, общепринятый"],
            "prior to": ["['praiətu]", "до, до момента"],
            "probe": ["[prəub]", "зонд"],
            "probity": ["['prəubəti]", "честность"],
            "procure": ["[prə'kjuə]", "доставать, доставлять"],
            "prodigious": ["[prə'diʤəs]", "чрезмерный, непомерный"],
            "profane": ["[prə'fein]", "мирской"],
            "profuse": ["[prə'fju:s]", "обильный, щедрый"],
            "proliferate": ["[prə'lif(ə)reit]", "распространяться"],
            "promiscuous": ["[prə'miskjuəs]", "беспорядочный, неразборчивый"],
            "pronounced": ["[prə'naun(t)st]", "резко выраженный"],
            "prophesy": ["['prоfəsai]", "предсказывать, пророчить"],
            "propriety": ["[prə'praiəti]", "правильность, правомерность"],
            "proscribe": ["[prə'skraib]", "объявлять вне закона"],
            "protagonist": ["[prə'tæg(ə)nist]", "главный герой"],
            "protracted": ["[prə'træktid]", "затянувшийся"],
            "provenance": ["['prоv(ə)nən(t)s]", "происхождение, источник"],
            "provoke": ["[prə'vəuk]", "вызывать, возбуждать"],
            "prudent": ["['pru:d(ə)nt]", "благоразумный, предусмотрительный"],
            "pugnacious": ["[p∧g'nei∫əs]", "драчливый"],
            "pulverize": ["['p∧lv(ə)raiz]", "растирать, дробить"],
            "quake": ["[kweik]", "трястись, дрожать"],
            "quandary": ["['kwоnd(ə)ri]", "затруднительное положение"],
            "quarrel": ["['kwоr(ə)l]", "ссора"],
            "quash": ["[kwо∫]", "аннулировать, отменять"],
            "quench": ["[kwenʧ]", "гасить, тушить"],
            "query": ["['kwiəri]", "вопрос"],
            "quicksilver": ["['kwik,silvə]", "ртуть"],
            "ragged robin": ["['rægid,rоbin]", "дрёма, кукушкин цвет"],
            "raid": ["[reid]", "внезапное нападение"],
            "raze": ["[reiz]", "разрушать до основания"],
            "rebellion": ["[ri'beliən]", "восстание"],
            "reckless": ["['rekləs]", "необдуманный, безрассудный"],
            "recollect": ["[,rek(ə)'lekt]", "вспоминать, припоминать"],
            "reconcile": ["['rek(ə)nsail]", "мирить, помирить"],
            "recount": ["[,ri:'kaunt]", "рассказывать, излагать подробно"],
            "recurring decimal": ["[ri'kə:riɳ'desim(ə)l]", "периодическая десятичная дробь"],
            "redeem": ["[ri'di:m]", "выкупать"],
            "redoubtable": ["[ri'dautəbl]", "страшный, грозный"],
            "refine": ["[ri'fain]", "очищать, рафинировать"],
            "refurbish": ["[,ri:'fə:bi∫]", "подновлять"],
            "rehabilitate": ["[,ri:hə'biliteit]", "реабилитировать"],
            "rehearse": ["[ri'hə:s]", "репетировать"],
            "reimburse": ["[,ri:im'bə:s]", "возвращать, возмещать"],
            "release gear": ["[ri'li:sgiə]", "бомбосбрасыватель"],
            "relish": ["['reli∫]", "вкус, привкус"],
            "remit": ["[ri'mit]", "прощать"],
            "remnant": ["['remnənt]", "остаток"],
            "remunerate": ["[ri'mju:n(ə)reit]", "вознаграждать"],
            "renounce": ["[ri'naun(t)s]", "отказываться"],
            "Ed": ["[ed]", "Эд"],
            "repel": ["[ri'pel]", "отбрасывать, отражать"],
            "repercussion": ["[,ri:pə'k∧∫(ə)n]", "отдача"],
            "reproach": ["[ri'prəuʧ]", "бранить"],
            "reprobate": ["['reprəbeit]", "негодяй, подлец"],
            "veal": ["[vi:l]", "телятина"],
            "repugnance": ["[ri'p∧gnən(t)s]", "отвращение, антипатия"],
            "rescind": ["[ri'sind]", "аннулировать, расторгать"],
            "resent": ["[ri'zent]", "негодовать, возмущаться"],
            "residual": ["[ri'zidjuəl]", "остаточный"],
            "resolute": ["['rez(ə)lu:t]", "непоколебимый, решительный"],
            "resound": ["[ri'zaund]", "громко звучать, раздаваться"],
            "restless": ["['restləs]", "беспокойный, неугомонный"],
            "retaliate": ["[ri'tælieit]", "отвечать"],
            "reticent": ["['retis(ə)nt]", "молчаливый, немногословный"],
            "retraction": ["[ri'træk∫(ə)n]", "втягивание"],
            "retreat": ["[ri'tri:t]", "отступать, отходить"],
            "reveal": ["[ri'vi:l]", "открывать"],
            "revere": ["[ri'viə]", "уважать"],
            "revoke": ["[ri'vəuk]", "отменять, аннулировать"],
            "riddle": ["['ridl]", "загадка"],
            "rigour": ["['rigə]", "строгость, суровость"],
            "risky": ["['riski]", "опасный, рискованный"],
            "roam": ["[rəum]", "бродить, путешествовать"],
            "rotundity": ["[rə't∧ndəti]", "округлённость"],
            "rudiment": ["['ru:dimənt, 'ru:dəmənt]", "начальные знания, основы"],
            "rummage sale": ["['r∧miʤ'seil]", "распродажа невостребованных товаров"],
            "rumour": ["['ru:mə]", "молва, слух"],
            "salvage": ["['sælviʤ]", "спасение имущества"],
            "sanction": ["['sæɳ(k)(∫)(ə)n]", "официальное одобрение, разрешение"],
            "sanctuary": ["['sæɳ(k)ʧuəri]", "святилище"],
            "sanguine": ["['sæɳgwin]", "сангвинический"],
            "scan": ["[skæn]", "through бегло просматривать"],
            "scant": ["[skænt]", "скудный, недостаточный"],
            "scarce": ["[skɛəs]", "недостаточный, скудный"],
            "scholarly": ["['skоləli]", "учёный"],
            "scorn": ["[sko:n]", "презрение, пренебрежение"],
            "Ouse": ["[u:z]", "Уз"],
            "seduction": ["[si'd∧k∫(ə)n]", "обольщение"],
            "seemly": ["['si:mli]", "подобающий, приличествующий"],
            "sequential": ["[si'kwen(t)∫(ə)l]", "являющийся продолжением"],
            "sequester": ["[si'kwestə]", "изолировать, отделять"],
            "serene": ["[si'ri:n]", "ясный"],
            "serpent": ["['sə:p(ə)nt]", "змея, змей"],
            "sever": ["['sevə]", "отделять, разделять"],
            "shabby": ["['∫æbi]", "поношенный"],
            "shatter": ["['∫ætə]", "разбить вдребезги"],
            "shimmer": ["['∫imə]", "мерцать"],
            "shiver": ["['∫ivə]", "трепетать"],
            "shortcoming": ["[,∫o:t'k∧miɳ]", "отсутствие, недостаток"],
            "shred": ["[∫red]", "клочок, кусочек"],
            "shun": ["[∫∧n]", "беречься, избегать"],
            "signify": ["['signifai]", "значить, означать"],
            "simulate": ["['simjəleit]", "симулировать"],
            "sip": ["[sip]", "маленький глоток"],
            "sceptical": ["['skeptik(ə)l]", "скептический"],
            "skid": ["[skid]", "скаты, полоз"],
            "skinny": ["['skini]", "худой, тощий"],
            "slander": ["['sla:ndə]", "злословие, клевета"],
            "sly": ["[slai]", "коварный, ловкий"],
            "smoulder": ["['sməuldə]", "густое облако дыма"],
            "sojourn": ["['sоʤə:n]", "временное пребывание"],
            "solicit": ["[sə'lisit]", "просить, упрашивать"],
            "sophistry": ["['sоfistri]", "софистика"],
            "spawn": ["[spo:n]", "икра"],
            "spectacular": ["[spek'tækjələ]", "производящий глубокое впечатление"],
            "spirited": ["['spiritid]", "живой, оживлённый"],
            "splendid": ["['splendid]", "роскошный, пышный"],
            "spoil": ["[spоil]", "трофеи"],
            "spouse": ["[spauz]", "муж, супруг"],
            "spurious": ["['spjuəriəs]", "поддельный"],
            "squander": ["['skwоndə]", "расточительство"],
            "stagnant": ["['stægnənt]", "стоячий"],
            "stain": ["[stein]", "пятно"],
            "stale": ["[steil]", "несвежий, чёрствый"],
            "stall": ["[sto:l]", "стойло"],
            "status quo": ["[,steitəs'kwəu]", "статус-кво, положение вещей"],
            "stealthy": ["['stelθi]", "незаметный, скрытый"],
            "steep": ["[sti:p]", "крутой"],
            "stentorian": ["[sten'to:riən]", "громоподобный, зычный"],
            "stifle": ["['staifl]", "душить"],
            "stifling": ["['staifliɳ]", "душный"],
            "strenuous": ["['strenjuəs]", "энергичный"],
            "strife": ["[straif]", "борьба"],
            "strive": ["[straiv]", "стараться, пытаться"],
            "stumble": ["['st∧mbl]", "спотыкание"],
            "stun grenade": ["['st∧ngri,neid]", "свето-шумовая граната"],
            "stupendous": ["[stju:'pendəs]", "громадный"],
            "sturdy": ["['stə:di]", "прочный, крепкий"],
            "sublime": ["[sə'blaim]", "высочайший, величайший"],
            "submerge": ["[səb'mə:ʤ]", "окунать"],
            "subsequent": ["['s∧bsikwənt]", "более поздний, последующий"],
            "subside": ["[səb'said]", "опускаться, падать"],
            "subsidiary": ["[səb'sidi(ə)ri]", "второстепенный"],
            "sundry": ["['s∧ndri]", "различный, разный"],
            "superb": ["[su:'pə:b]", "великолепный"],
            "supplant": ["[sə'pla:nt]", "выжить, вытеснить"],
            "supplicate": ["['s∧plikeit]", "молить, просить"],
            "surfeit": ["['sə:fit]", "излишество, неумеренность"],
            "surge": ["[sə:ʤ]", "большая волна"],
            "surly": ["['sə:li]", "угрюмый, сердитый"],
            "surmise": ["[sə'maiz]", "догадка, подозрение"],
            "surpass": ["[sə'pa:s]", "превосходить, превышать"],
            "suspend": ["[sə'spend]", "вешать, подвешивать"],
            "sybaritic": ["[,sib(ə)'ritik]", "сибаритский"],
            "synagogue": ["['sinəgоg]", "синагога"],
            "synopsis": ["[si'nоpsis]", "конспект, краткий обзор"],
            "synthesize": ["['sinθəsaiz]", "синтезировать"],
            "taciturn": ["['tæsitə:n]", "молчаливый"],
            "tact": ["[tækt]", "такт, тактичность"],
            "tactic": ["['tæktik]", "относящийся к расположению"],
            "taint": ["[teint]", "пятно"],
            "tale": ["[teil]", "рассказ"],
            "tame": ["[teim]", "приручённый, одомашненный"],
            "tangle": ["['tæɳgl]", "спутанный клубок"],
            "tantalize": ["['tænt(ə)laiz]", "манить, соблазнять"],
            "tantamount": ["['tæntəmaunt]", "эквивалентный, равносильный"],
            "tardy": ["['ta:di]", "медлительный"],
            "tarnish": ["['ta:ni∫]", "тусклость"],
            "taunt": ["[to:nt]", "насмешка, язвительное замечание"],
            "tautology": ["[to:'tоləʤi]", "повторение, тавтология"],
            "tawdry": ["['to:dri]", "мишурный, кричаще безвкусный"],
            "taxonomy": ["[tæk'sоnəmi]", "систематика, таксономия"],
            "tedious": ["['ti:diəs]", "нудный, скучный"],
            "tempting": ["['tem(p)tiɳ]", "заманчивый, привлекательный"],
            "tenor": ["['tenə]", "направление, течение"],
            "tepid": ["['tepid]", "тепловатый, чуть тёплый"],
            "tether": ["['te∂ə]", "привязь"],
            "thaw": ["[θo:]", "оттепель"],
            "thermal capacity": ["['θə:m(ə)lkə'pæsiti]", "теплоёмкость"],
            "thorough bass": ["['θ∧rəbeis]", "генерал-бас"],
            "thoroughfare": ["['θ∧rəfɛə]", "оживлённая улица"],
            "thrifty": ["['θrifti]", "бережливый, расчётливый"],
            "thrilling": ["['θriliɳ]", "волнующий, захватывающий"],
            "thrive": ["[θraiv]", "благоденствовать, преуспевать"],
            "tidings": ["['taidiɳz]", "известия, новости"],
            "tilt hammer": ["['tilt,hæmə]", "хвостовой молот"],
            "timid": ["['timid]", "робкий"],
            "tint": ["[tint]", "краска"],
            "tiresome": ["['taiəsəm]", "утомительный, изнурительный"],
            "toil": ["[tоil]", "тяжёлый труд"],
            "tolerant": ["['tоl(ə)r(ə)nt]", "терпимый, относящийся терпимо"],
            "torpid": ["['to:pid]", "онемелый, оцепеневший"],
            "torrent": ["['tоr(ə)nt]", "стремительный поток"],
            "torture": ["['to:ʧə]", "пытка"],
            "tow": ["[təu]", "бечева"],
            "towering": ["['tauəriɳ]", "высокий, вздымающийся"],
            "trailblazer": ["['treil,bleizə]", "новатор, пионер"],
            "trajectory": ["[trə'ʤekt(ə)ri]", "траектория"],
            "transmute": ["[trænz'mju:t]", "изменяться, превращаться"],
            "entablature": ["[en'tæbləʧə]", "антаблемент"],
            "transpose": ["[træn'spəuz]", "переносить, перемещать"],
            "treacherous": ["['treʧ(ə)rəs]", "вероломный, изменнический"],
            "tremendous": ["[tri'mendəs]", "огромный, гигантский"],
            "trepidation": ["[,trepi'dei∫(ə)n]", "трепет, дрожь"],
            "trying plane": ["['traiiɳplein]", "фуганок"],
            "tumultuous": ["[tju:'m∧lʧuəs]", "шумный, буйный"],
            "turbulent": ["['tə:bjulənt]", "бурный, бушующий"],
            "unattended": ["[,∧nə'tendid]", "без сопровождения"],
            "unbearable": ["[∧n'bɛərəbl]", "невыносимый, нетерпимый"],
            "uncanny": ["[∧n'kæni]", "сверхъестественный, необъяснимый"],
            "uncouth": ["[∧n'ku:θ]", "грубый, неотёсанный"],
            "undergo": ["[,∧ndə'gəu]", "испытывать, переносить"],
            "undertake": ["[,∧ndə'teik]", "предпринимать, совершать"],
            "undulate": ["['∧ndjəleit]", "волнистый, волнообразный"],
            "unerring": ["[∧n'ə:riɳ]", "безошибочный, верный"],
            "ungainly": ["[∧n'geinli]", "неловкий, нескладный"],
            "unruly": ["[∧n'ru:li]", "буйный, непокорный"],
            "unscathed": ["[∧n'skei∂d]", "невредимый, неповреждённый"],
            "unsound": ["[∧n'saund]", "болезненный"],
            "uphold": ["[∧p'həuld]", "поддерживать, помогать"],
            "uptight": ["[∧p'tait]", "встревоженный, взволнованный"],
            "urinary": ["['juərin(ə)ri]", "мочевой"],
            "usurp": ["[ju:'zə:p]", "узурпировать, незаконно захватывать"],
            "vacuous": ["['vækjuəs]", "пустой, незаполненный"],
            "vain": ["[vein]", "тщеславный"],
            "vanguard": ["['vænga:d]", "головной отряд, авангард"],
            "vanity bag": ["['vænəti,bæg]", "косметичка"],
            "variation": ["[,vɛəri'ei∫(ə)n]", "изменение, варьирование"],
            "vaunt": ["[vo:nt]", "хвастовство"],
            "vehemence": ["['vi:əmən(t)s]", "сила"],
            "vein": ["[vein]", "вена"],
            "venerate": ["['ven(ə)reit]", "благоговеть"],
            "venereal": ["[və'niəriəl]", "венерический"],
            "venomous": ["['venəməs]", "ядовитый"],
            "venue": ["['venju:]", "место проведения"],
            "verbose": ["[və:'bəus]", "многословный"],
            "verify": ["['verifai]", "проверять, контролировать"],
            "versatile": ["['və:sətail]", "многосторонний, многогранный"],
            "vessel": ["['ves(ə)l]", "сосуд"],
            "vigorous": ["['vig(ə)rəs]", "сильный, энергичный"],
            "vindicate": ["['vindikeit]", "доказывать"],
            "vivid": ["['vivid]", "яркий"],
            "vogue": ["[vəug]", "мода"],
            "voluptuous": ["[və'l∧pʧuəs]", "чувственный"],
            "wage cut": ["['weiʤk∧t]", "снижение заработной платы"],
            "wail": ["[weil]", "продолжительный скорбный крик"],
            "walkout": ["['wo:kaut]", "забастовка, стачка"],
            "wan": ["[wоn]", "бледный, изнурённый"],
            "wane": ["[wein]", "спад, упадок"],
            "waxy": ["['wæksi]", "восковой"],
            "weary": ["['wiəri]", "усталый, изнурённый"],
            "wholesome": ["['həuls(ə)m]", "полезный"],
            "wicked": ["['wikid]", "злой, злобный"],
            "wile": ["[wail]", "хитрость, уловка"],
            "winsome": ["['winsəm]", "приятный, миловидный"],
            "wise guy": ["['waizgai]", "умник, всезнайка"],
            "wither": ["['wi∂ə]", "вянуть, сохнуть"],
            "withstand": ["[wi∂'stænd]", "устоять"],
            "wonder": ["['w∧ndə]", "удивление, изумление"],
            "wound": ["[wu:nd]", "рана"],
            "wrinkle": ["['riɳkl]", "морщина"],
            "zealous": ["['zeləs]", "рьяный, усердный"],
            "zone": ["[zəun]", "зона, пояс"],
            "abundant": ["[ə'b∧ndənt]", "обильный, богатый"],
            "accurate": ["['ækjərət]", "верный, правильный"],
            "acute": ["[ə'kju:t]", "остроконечный, острый"],
            "adjacent": ["[ə'ʤeis(ə)nt]", "расположенный рядом, смежный"],
            "adverse": ["['ædvə:s]", "враждебный"],
            "aggregate": ["['ægrigət]", "множество, совокупность"],
            "agrarian": ["[ə'grɛəriən]", "аграрный, земельный"],
            "amnesia": ["[æm'ni:ziə]", "потеря памяти, амнезия"],
            "annual": ["['ænjuəl]", "ежегодный"],
            "apparent": ["[ə'pær(ə)nt]", "видимый, видный"],
            "artificial": ["[,a:ti'fi∫(ə)l]", "искусственный, ненатуральный"],
            "auditory": ["['o:dit(ə)ri]", "слуховой"],
            "authentic": ["[o:'θentik]", "аутентичный, истинный"],
            "bachelor": ["['bæʧ(ə)lə]", "холостяк"],
            "bare": ["[bɛə]", "голый, нагой"],
            "barter": ["['ba:tə]", "бартер, меновая торговля"],
            "beam": ["[bi:m]", "луч"],
            "bellicose": ["['belikəus]", "воинственный, воинствующий"],
            "bilateral": ["[bai'læt(ə)r(ə)l]", "двусторонний"],
            "blatant": ["['bleit(ə)nt]", "вульгарный, крикливый"],
            "blunder": ["['bl∧ndə]", "грубая ошибка"],
            "brace": ["[breis]", "связь"],
            "breathtaking": ["['breθ,teikiɳ]", "захватывающий, изумительный"],
            "breeze": ["[bri:z]", "лёгкий ветерок, бриз"],
            "casual": ["['kæƷwəl]", "случайный, бессистемный"],
            "cavity": ["['kævəti]", "впадина"],
            "census": ["['sen(t)səs]", "перепись"],
            "clandestine": ["[klæn'destin]", "тайный, скрытый"],
            "coalition": ["[kəuə'li∫(ə)n]", "объединение, соединение"],
            "coherent": ["[kə(u)'hiər(ə)nt]", "сцепленный, связанный"],
            "commitment": ["[kə'mitmənt]", "обязательство"],
            "commodity": ["[kə'mоdəti]", "предмет потребления"],
            "competent": ["['kоmpit(ə)nt]", "осведомлённый, сведущий"],
            "compulsory": ["[kəm'p∧ls(ə)ri]", "принудительный"],
            "confidential": ["[,kоnfi'den(t)∫(ə)l]", "частный, личный"],
            "contempt": ["[kən'tempt]", "презрение"],
            "crucial": ["['kru:∫(ə)l]", "ключевой"],
            "crude": ["[kru:d]", "сырая нефть"],
            "defective": ["[di'fektiv]", "имеющий недостатки, дефекты"],
            "deliberate": ["[di'lib(ə)rit]", "неслучайный, тщательно спланированный"],
            "delicate": ["['delikit]", "изысканный, тонкий"],
            "device": ["[di'vais]", "устройство, приспособление"],
            "elasticity": ["[,ilæs'tisəti]", "эластичность"],
            "equitable": ["['ekwitəbl]", "беспристрастный, непредубеждённый"],
            "escalate": ["['eskəleit]", "подниматься на эскалаторе"],
            "essential": ["[i'sen(t)∫(ə)l]", "внутренне присущий, неотъемлемый"],
            "explicit": ["[ik'splisit]", "ясный, подробный"],
            "extraneous": ["[ik'streiniəs]", "внешний, поступающий извне"],
            "facile": ["['fæsail]", "лёгкий, легко обретённый"],
            "famine": ["['fæmin]", "голод"],
            "fatigue": ["[fə'ti:g]", "усталость, утомление"],
            "consecutive": ["[kən'sekjutiv]", "последовательный"],
            "cordial": ["['ko:diəl]", "сердечный, задушевный"],
            "crooked": ["['krukid]", "изогнутый, кривой"],
            "edible": ["['edibl]", "съедобный"],
            "efface": ["[i'feis]", "стирать, вычёркивать"],
            "facility": ["[fə'siləti]", "возможность, благоприятные условия"],
            "flexible": ["['fleksəbl]", "гибкий"],
            "fusion": ["['fju:Ʒ(ə)n]", "плавка"],
            "harness": ["['ha:nis, 'ha:nəs]", "упряжь, сбруя"],
            "harsh": ["[ha:∫]", "жёсткий, твёрдый"],
            "hasty": ["['heisti]", "быстрый, скорый"],
            "imminent": ["['iminənt]", "надвигающийся, неотвратимый"],
            "immortal": ["[i'mo:t(ə)l]", "вечный, бессмертный"],
            "impartial": ["[im'pa:∫(ə)l]", "беспристрастный, справедливый"],
            "impromptu": ["[im'prоmptju:]", "экспромт"],
            "incandescent": ["[,inkæn'des(ə)nt]", "раскалённый, накалённый добела"],
            "incentive": ["[in'sentiv]", "побуждение, стимул"],
            "instantaneous": ["[,in(t)stən'teiniəs]", "мгновенный"],
            "interim": ["['int(ə)rim]", "промежуток времени"],
            "intractable": ["[in'træktəbl]", "упрямый, неподатливый"],
            "latent": ["['leit(ə)nt]", "скрытый, латентный"],
            "maiden": ["['meid(ə)n]", "дева, девица"],
            "malignant": ["[mə'lignənt]", "злобный"],
        },
        words = Object.keys(dict);
    
    
    provide({
       random: function randomWord(oldWord) {
           var newWord = words[Math.floor(Math.random()*words.length)]
           return newWord !== oldWord ? newWord : randomWord(oldWord);
       },
       
       translate: function(word) {
           return (dict[word] && dict[word][1]) || "Ooops... It's too hard to translate :(";
       },
       
       transcript: function(word) {
           return (dict[word] && dict[word][0]) || "";
       }
    });
    
});

/* ../../common.blocks/dict/dict.js end */
;
/* ../../libs/bem-core/common.blocks/strings/__escape/strings__escape.vanilla.js begin */
/**
 * @module strings__escape
 * @description A set of string escaping functions
 */

modules.define('strings__escape', function(provide) {

var symbols = {
        '"' : '&quot;',
        '\'' : '&apos;',
        '&' : '&amp;',
        '<' : '&lt;',
        '>' : '&gt;'
    },
    mapSymbol = function(s) {
        return symbols[s] || s;
    },
    buildEscape = function(regexp) {
        regexp = new RegExp(regexp, 'g');
        return function(str) {
            return ('' + str).replace(regexp, mapSymbol);
        };
    };

provide(/** @exports */{
    /**
     * Escape string to use in XML
     * @type Function
     * @param {String} str
     * @returns {String}
     */
    xml : buildEscape('[&<>]'),

    /**
     * Escape string to use in HTML
     * @type Function
     * @param {String} str
     * @returns {String}
     */
    html : buildEscape('[&<>]'),

    /**
     * Escape string to use in attributes
     * @type Function
     * @param {String} str
     * @returns {String}
     */
    attr : buildEscape('["\'&<>]')
});

});

/* ../../libs/bem-core/common.blocks/strings/__escape/strings__escape.vanilla.js end */
;
/* ../../libs/bem-core/common.blocks/keyboard/__codes/keyboard__codes.js begin */
/**
 * @module keyboard__codes
 */
modules.define('keyboard__codes', function(provide) {

provide(/** @exports */{
    BACKSPACE : 8,
    TAB : 9,
    ENTER : 13,
    CAPS_LOCK : 20,
    ESC : 27,
    SPACE : 32,
    PAGE_UP : 33,
    PAGE_DOWN : 34,
    END : 35,
    HOME : 36,
    LEFT : 37,
    UP : 38,
    RIGHT : 39,
    DOWN : 40,
    INSERT : 41,
    DELETE : 42
});

});

/* ../../libs/bem-core/common.blocks/keyboard/__codes/keyboard__codes.js end */
;
